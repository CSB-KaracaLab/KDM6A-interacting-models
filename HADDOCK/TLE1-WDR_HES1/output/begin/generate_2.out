          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3 at patch level U
           Status: Special UU release with Rg, paramagnetic
                   and Z-restraints (A. Bonvin, UU 2013)
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: node002.cluster (x86_64/Linux,64-bit)
           Program started by: enmr
           Program started at: 23:48:28 on 01-Nov-2022
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>! generate.inp 
 CNSsolve>!     Generates missing coordinates and topology 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * and from the CNS distriution of Brunger and Adams                   * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{+ file: generate.inp +} 
 CNSsolve>{+ directory: general +} 
 CNSsolve>{+ description: Generate coordinate and structure file for simple models +} 
 CNSsolve>{+ comment: 
 CNSsolve>           This is designed to be a means of generating a coordinate 
 CNSsolve>           and structure file for commonly encountered models: protein 
 CNSsolve>           and/or DNA/RNA. The coordinates 
 CNSsolve>           are provided by the user in a single input PDB file. 
 CNSsolve>           Disulphide bonds will be automatically determined by distance. 
 CNSsolve>           If required generate hydrogens. Any atoms with unknown 
 CNSsolve>           coordinates can be automatically generated +} 
 CNSsolve>{+ authors: Paul Adams and Axel Brunger +} 
 CNSsolve>{+ copyright: Yale University +} 
 CNSsolve> 
 CNSsolve>{+ Adapted for use in HADDOCK by Alexandre Bonvin, Utrecht University Feb-2002 +} 
 CNSsolve> 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file -} 
 CNSsolve> 
 CNSsolve>{- Special patches will have to be entered manually at the relevant points 
 CNSsolve>   in the file - see comments throughout the file -} 
 CNSsolve> 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE> 
 DEFINE>{============================== important =================================} 
 DEFINE> 
 DEFINE>{* Different chains in the structure must have either unique segid or 
 DEFINE>   chainid records. If this is no the case, the end of a chain must 
 DEFINE>   be delimited by a TER card. *} 
 DEFINE> 
 DEFINE>{* A break in a chain can be detected automatically or should be delimited 
 DEFINE>   by a BREAK card. In this case no patch (head, tail or link) will be 
 DEFINE>   applied between the residues that bound the chain break. *} 
 DEFINE> 
 DEFINE>{* NB. The input PDB file must finish with an END statement *} 
 DEFINE> 
 DEFINE>{=========================== coordinate files =============================} 
 DEFINE> 
 DEFINE>{* coordinate file *} 
 DEFINE>{===>} coordinate_infile="/home/abonvin/software/haddock/examples/e2a.pdb"; 
 DEFINE> 
 DEFINE>{* convert chainid to segid if chainid is non-blank *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} convert=false; 
 DEFINE> 
 DEFINE>{* separate chains by segid - a new segid starts a new chain *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} separate=true; 
 DEFINE>{============================ renaming atoms ===============================} 
 DEFINE> 
 DEFINE>{* some atoms may need to be renamed in the topology database to conform 
 DEFINE>   to what is present in the coordinate file *} 
 DEFINE> 
 DEFINE>{* delta carbon in isoleucine is named CD in CNS 
 DEFINE>   what is it currently called in the coordinate file? *} 
 DEFINE>{* this will not be changed if left blank *} 
 DEFINE>{===>} ile_CD_becomes="CD1"; 
 DEFINE> 
 DEFINE>{* terminal oxygens are named OT1 and OT2 in CNS 
 DEFINE>   what are they currently called in the coordinate file? *} 
 DEFINE>{* these will not be changed if left blank *} 
 DEFINE>{===>} OT1_becomes="O"; 
 DEFINE>{===>} OT2_becomes="OXT"; 
 DEFINE> 
 DEFINE>{======================= automatic mainchain breaks ========================} 
 DEFINE> 
 DEFINE>{* automatically detect mainchain breaks in proteins based on distance *} 
 DEFINE>{* the peptide link at break points will be removed *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} auto_break=true; 
 DEFINE> 
 DEFINE>{* cutoff distance in Angstroms for identification of breaks *} 
 DEFINE>{* the default of 2.5A for peptide bonds should be reasonable for most cases. If the input 
 DEFINE>   structure has bad geometry it may be necessary to increase this distance *} 
 DEFINE>{===>} pbreak_cutoff=3.5; 
 DEFINE>{===>} pcgbreak_cutoff=8.0; 
 DEFINE>{* the default of 2.5A for nucleic acid linkages should be reasonable for most cases. If the input 
 DEFINE>   structure has bad geometry it may be necessary to increase this distance *} 
 DEFINE>{===>} dbreak_cutoff=4.5; 
 DEFINE> 
 DEFINE>{* file containing patches to delete peptide links *} 
 DEFINE>{===>} prot_break_infile="RUN:toppar/protein_break.top"; 
 DEFINE> 
 DEFINE>{* file containing patches to delete nucleic acid links *} 
 DEFINE>{===>} dna_break_infile="RUN:toppar/dna_break.top"; 
 DEFINE> 
 DEFINE>{======================= automatic disulphide bonds ========================} 
 DEFINE> 
 DEFINE>{* cutoff distance in Angstroms for identification of disulphides *} 
 DEFINE>{* the default of 3.0A should be reasonable for most cases. If the input 
 DEFINE>   structure has bad geometry it may be necessary to increase this distance *} 
 DEFINE>{===>} disulphide_dist=3.0; 
 DEFINE> 
 DEFINE>{======================= automatic cyclic peptidic bond ====================} 
 DEFINE> 
 DEFINE>{* cutoff distance in Angstroms for identification of cyclic peptide*} 
 DEFINE>{* the default of 2.0A should be reasonable for most cases. If the input 
 DEFINE>   structure has bad geometry it may be necessary to increase this distance *} 
 DEFINE>{===>} cyclicpept_dist=2.0; 
 DEFINE> 
 DEFINE>{======================= automatic iron cluster bonds ======================} 
 DEFINE> 
 DEFINE>{* cutoff distance in Angstroms for identification of iron cluster bonds *} 
 DEFINE>{* the default of 8.0A should be reasonable for most cases. If the input 
 DEFINE>   structure has bad geometry it may be necessary to increase this distance *} 
 DEFINE>{===>} iron1cluster_dist=5.0; 
 DEFINE>{===>} iron2cluster_dist=8.0; 
 DEFINE> 
 DEFINE>{======================= automatic cis peptide bonds =======================} 
 DEFINE> 
 DEFINE>{* select atoms to be included in calculation of omega angles *} 
 DEFINE>{* to define cis peptides*} 
 DEFINE>{===>} atom_select=(known and not hydrogen); 
 DEFINE> 
 DEFINE>{========================= RNA to DNA conversion  ==========================} 
 DEFINE> 
 DEFINE>{* All nucleic acid residues initially have ribose sugars (rather than 
 DEFINE>   deoxyribose). A patch must be applied to convert the ribose to deoxyribose 
 DEFINE>   for DNA residues. Select those residues which need to have the patch 
 DEFINE>   applied to make them DNA. *} 
 DEFINE>{* Make sure that the atom selection is specific for the nucleic acid 
 DEFINE>   residues *} 
 DEFINE>{===>} dna_sele=(none); 
 DEFINE> 
 DEFINE>{========================= generate parameters =============================} 
 DEFINE> 
 DEFINE>{* hydrogen flag - determines whether hydrogens will be output *} 
 DEFINE>{* must be true for NMR, atomic resolution X-ray crystallography 
 DEFINE>   or modelling.  Set to false for most X-ray crystallographic 
 DEFINE>   applications at resolution > 1A *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} hydrogen_flag=true; 
 DEFINE> 
 DEFINE>{* which hydrogens to build *} 
 DEFINE>{+ choice: "all" "unknown" +} 
 DEFINE>{===>} hydrogen_build="all"; 
 DEFINE> 
 DEFINE>{* selection of atoms other than hydrogens for which coordinates 
 DEFINE>   will be generated *} 
 DEFINE>{* to generate coordinates for all unknown atoms use: (not(known)) *} 
 DEFINE>{===>} atom_build=(not(known)); 
 DEFINE> 
 DEFINE>{* selection of atoms to be deleted *} 
 DEFINE>{* to delete no atoms use: (none) *} 
 DEFINE>{===>} atom_delete=(none); 
 DEFINE> 
 DEFINE>{* set bfactor flag *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} set_bfactor=true; 
 DEFINE> 
 DEFINE>{* set bfactor value *} 
 DEFINE>{===>} bfactor=15.0; 
 DEFINE> 
 DEFINE>{* set occupancy flag *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} set_occupancy=false; 
 DEFINE> 
 DEFINE>{* set occupancy value *} 
 DEFINE>{===>} occupancy=1.0; 
 DEFINE> 
 DEFINE>{============================= output files ================================} 
 DEFINE> 
 DEFINE>{* output structure file *} 
 DEFINE>{===>} structure_outfile="haddock.psf"; 
 DEFINE> 
 DEFINE>{* output coordinate file *} 
 DEFINE>{===>} coordinate_outfile="haddock.pdb"; 
 DEFINE> 
 DEFINE>{================== protein topology and parameter files ===================} 
 DEFINE> 
 DEFINE>{* protein topology file *} 
 DEFINE>{===>} prot_topology_infile="RUN:toppar/protein-allhdg5-4.top"; 
 DEFINE> 
 DEFINE>{* protein linkage file *} 
 DEFINE>{===>} prot_link_infile="RUN:toppar/protein-allhdg5-4-noter.link"; 
 DEFINE> 
 DEFINE>{* protein parameter file *} 
 DEFINE>{===>} prot_parameter_infile="RUN:toppar/protein-allhdg5-4.param"; 
 DEFINE> 
 DEFINE>{================ nucleic acid topology and parameter files =================} 
 DEFINE> 
 DEFINE>{* nucleic acid topology file *} 
 DEFINE>{===>} nucl_topology_infile="RUN:toppar/dna-rna-allatom-hj-opls-1.3.top"; 
 DEFINE> 
 DEFINE>{* nucleic acid linkage file *} 
 DEFINE>{* use RUN:/toppar/dna-rna-pho.link for 5'-phosphate *} 
 DEFINE>{===>} nucl_link_infile="RUN:/toppar/dna-rna-1.3.link"; 
 DEFINE> 
 DEFINE>{* nucleic acid parameter file *} 
 DEFINE>{===>} nucl_parameter_infile="RUN:/toppar/dna-rna-allatom-hj-opls-1.3.param"; 
 DEFINE> 
 DEFINE>{================= carbohydrate topology and parameter files ===============} 
 DEFINE> 
 DEFINE>{* carbohydrate topology file *} 
 DEFINE>{===>} carbo_topology_infile="RUN:/toppar/carbohydrate.top"; 
 DEFINE> 
 DEFINE>{* carbohydrate parameter file *} 
 DEFINE>{===>} carbo_parameter_infile="RUN:/toppar/carbohydrate.param"; 
 DEFINE> 
 DEFINE>{================= solvent topology and parameter files ====================} 
 DEFINE> 
 DEFINE>{* solvent topology file *} 
 DEFINE>{===>} solv_topology_infile="RUN:/toppar/water-allhdg5-4.top"; 
 DEFINE> 
 DEFINE>{* solvent parameter file *} 
 DEFINE>{===>} solv_parameter_infile="RUN:/toppar/water-allhdg5-4.param"; 
 DEFINE> 
 DEFINE>{================= cofactor topology and parameter files ===================} 
 DEFINE> 
 DEFINE>{* co-factor topology file *} 
 DEFINE>{===>} cofac_topology_infile="RUN:/toppar/ligand.top"; 
 DEFINE> 
 DEFINE>{* co-factor linkage file *} 
 DEFINE>{===>} cofac_link_infile="RUN:toppar/ligand.pep"; 
 DEFINE> 
 DEFINE>{* co-factor parameter file *} 
 DEFINE>{===>} cofac_parameter_infile="RUN:/toppar/ligand.param"; 
 DEFINE> 
 DEFINE>{================= known ligands topology and parameter files ==============} 
 DEFINE> 
 DEFINE>{* ligands topology file *} 
 DEFINE>{===>} ligands_topology_infile="RUN:/toppar/fragment_probes.top"; 
 DEFINE> 
 DEFINE>{* ligands parameter file *} 
 DEFINE>{===>} ligands_parameter_infile="RUN:/toppar/fragment_probes.param"; 
 DEFINE> 
 DEFINE>{===================== ion topology and parameter files ====================} 
 DEFINE> 
 DEFINE>{* ion topology file *} 
 DEFINE>{===>} ion_topology_infile="RUN:/toppar/ion.top"; 
 DEFINE> 
 DEFINE>{* ion parameter file *} 
 DEFINE>{===>} ion_parameter_infile="RUN:/toppar/ion.param"; 
 DEFINE> 
 DEFINE>{===================== heme topology and parameter files ====================} 
 DEFINE> 
 DEFINE>{* heme topology file *} 
 DEFINE>{===>} heme_topology_infile="RUN:/toppar/hemes-allhdg.top"; 
 DEFINE> 
 DEFINE>{* heme parameter file *} 
 DEFINE>{===>} heme_parameter_infile="RUN:/toppar/hemes-allhdg.param"; 
 DEFINE> 
 DEFINE>{===================== default number of histidines for patching ===========} 
 DEFINE> 
 DEFINE> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve>@RUN:protocols/initialize.cns(iteration=$iteration;) 
 ASSFIL: file initialize.cns opened.
 CNSsolve>! initialize.cns 
 CNSsolve>!    Iteration initialization 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (iteration;) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration = "") 
 EVALUATE: symbol $_1_ITERATION set to "" (string)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>@RUN:begin/iteration.cns(iteration=$iteration;) 
 ASSFIL: file iteration.cns opened.
 CNSsolve>module ( iteration ) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration=0) 
 EVALUATE: symbol $_1_ITERATION set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>@RUN:run.cns( 
 ASSFIL: file run.cns opened.
 CNSsolve>! run.cns 
 CNSsolve>!    The file containing all parameters for HADDOCK 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>module( 
 MODULE-DECLARATION>iteration; 
 MODULE-DECLARATION>filenames; 
 MODULE-DECLARATION>data; 
 MODULE-DECLARATION>iterations; 
 MODULE-DECLARATION>saprotocol; 
 MODULE-DECLARATION>refine; 
 MODULE-DECLARATION>toppar; 
 MODULE-DECLARATION>analysis; 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>iteration =$iteration; 
 &_2_ITERATION set to $_1_ITERATION 
 MODULE-INVOCATION>filenames =$filenames; 
 &_2_FILENAMES set to $_1_FILENAMES 
 MODULE-INVOCATION>data      =$data; 
 &_2_DATA set to $_1_DATA 
 MODULE-INVOCATION>iterations=$iterations; 
 &_2_ITERATIONS set to $_1_ITERATIONS 
 MODULE-INVOCATION>saprotocol=$saprotocol; 
 &_2_SAPROTOCOL set to $_1_SAPROTOCOL 
 MODULE-INVOCATION>refine    =$refine; 
 &_2_REFINE set to $_1_REFINE 
 MODULE-INVOCATION>toppar    =$toppar; 
 &_2_TOPPAR set to $_1_TOPPAR 
 MODULE-INVOCATION>analysis  =$analysis; 
 &_2_ANALYSIS set to $_1_ANALYSIS 
 MODULE-INVOCATION>) 
 CNSsolve> 
 CNSsolve>{+ File: run.cns +} 
 CNSsolve>{+ Description: this file contains all necessary information to run HADDOCK. +} 
 CNSsolve> 
 CNSsolve>{+ Authors: Ezgi Karaca, Joao Rodrigues, Mikael Trellet, Alexandre Bonvin<br> 
 CNSsolve>Adapted from HADOOCK version 2.4 <br><br> 
 CNSsolve>Initially adapted from ARIA of Nilges and Linge +} 
 CNSsolve> 
 CNSsolve>{+ Please cite the following references when using this protocol: +} 
 CNSsolve>{+ reference: Cyril Dominguez, Rolf Boelens and Alexandre M.J.J. Bonvin (2003).  HADDOCK: a protein-protein docking approach 
 CNSsolve>based on biochemical and/or biophysical information. <i>J. Am. Chem. Soc.</i> <b>125</b>, 1731-1737. 
 CNSsolve><p> 
 CNSsolve><b>When using <i>residual dipolar couplings</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><LI>A.D.J. van Dijk, D. Fushman and A.M.J.J. Bonvin (2005). Various strategies of using residual dipolar 
 CNSsolve>couplings in NMR-driven protein docking: Application to Lys48-linked di-ubiquitin and validation against 
 CNSsolve>15N-relaxation data. <EM>Proteins: Struc. Funct. & Bioinformatics</EM>, <STRONG>60</STRONG>, 367-381.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>diffusion anisotropy data</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk, R. Kaptein, R. Boelens and A.M.J.J. Bonvin (2006). Combining NMR relaxation with 
 CNSsolve>chemical shift perturbation data to drive protein-protein docking. <EM>J. Biomol. NMR</EM>, 
 CNSsolve><STRONG>34</STRONG>, 237-244.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>solvated docking</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk and A.M.J.J. Bonvin (2006). Solvated docking: introducing water into the modelling 
 CNSsolve>of biomolecular complexes. <EM>Bioinformatics</EM>,  <STRONG>22</STRONG> 2340-2347. 
 CNSsolve><p> 
 CNSsolve><b>When performing <i>flexible protein-DNA docking</i> using HADDOCK cite in addition:</b><p> 
 CNSsolve><li>M. van Dijk, A.D.J. van Dijk, V. Hsu, R. Boelens and  A.M.J.J. Bonvin (2006). 
 CNSsolve>Information-driven Protein-DNA Docking using HADDOCK: it is a matter of flexibility. 
 CNSsolve><EM>Nucl. Acids Res.</EM>, <STRONG>34</STRONG> 3317-3325.</li> 
 CNSsolve><p> 
 CNSsolve><b>When performing the Nmolecule integrative modelling protocol please cite:</b><p> 
 CNSsolve><li>Ezgi Karaca, Joao P.G.L.M. Rodrigues, Andrea Graziadei, Alexandre M.J.J. Bonvin, Teresa Carlomagno (2017). 
 CNSsolve>An Integrative Framework for Structure Determination of Molecular Machines. 
 CNSsolve><EM>Nature Methods</EM>, Advanced Online Publication.</li> 
 CNSsolve>+} 
 CNSsolve> 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file 
 CNSsolve>   - pathnames should not exceed 80 characters -} 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE> 
 DEFINE> 
 DEFINE>{======== number of molecules for docking ==================} 
 DEFINE>{* number of components *} 
 DEFINE> 
 DEFINE>{===>} ncomponents=2; 
 DEFINE> 
 DEFINE>{======================= filenames =========================} 
 DEFINE>{*  the name of your current project *} 
 DEFINE>{*  this will be used as name for the generated structures *} 
 DEFINE>{===>} fileroot="complex"; 
 DEFINE> 
 DEFINE>{* RUN directory *} 
 DEFINE>{*  the absolute path of your current run, e.g. /home/haddock/run1*} 
 DEFINE>{===>} run_dir="/home/enmr/csb_webserver/data/runs/haddock24/userrun00188213/run1"; 
 DEFINE> 
 DEFINE>{* PDB file of molecule 1 *} 
 DEFINE>{===>} prot_coor_mol1="protein1.pdb"; 
 DEFINE>{* PSF file of molecule 1 *} 
 DEFINE>{===>} prot_psf_mol1="protein1.psf"; 
 DEFINE>{* segid of molecule 1 *} 
 DEFINE>{===>} prot_segid_mol1="A"; 
 DEFINE>{* fileroot of molecule 1 *} 
 DEFINE>{===>} prot_root_mol1="protein1"; 
 DEFINE>{* Fix Molecule at Origin during it0 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} fix_origin_mol1=false; 
 DEFINE>{* Is molecule 1 DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_mol1=false; 
 DEFINE>{* Is molecule 1 a cyclic peptide? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cyclicpept_mol1=false; 
 DEFINE>{* Is molecule 1 a shape? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} shape_mol1=false; 
 DEFINE>{* Coarse grained molecule? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cg_mol1=false; 
 DEFINE>{* PDB file of molecule 2 *} 
 DEFINE>{===>} prot_coor_mol2="protein2.pdb"; 
 DEFINE>{* PSF file of molecule 2 *} 
 DEFINE>{===>} prot_psf_mol2="protein2.psf"; 
 DEFINE>{* segid of molecule 2 *} 
 DEFINE>{===>} prot_segid_mol2="B"; 
 DEFINE>{* fileroot of molecule 2 *} 
 DEFINE>{===>} prot_root_mol2="protein2"; 
 DEFINE>{* Fix Molecule at Origin during it0 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} fix_origin_mol2=false; 
 DEFINE>{* Is molecule 2 DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_mol2=false; 
 DEFINE>{* Is molecule 2 a cyclic peptide? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cyclicpept_mol2=false; 
 DEFINE>{* Is molecule 2 a shape? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} shape_mol2=false; 
 DEFINE>{* Coarse grained molecule? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cg_mol2=false; 
 DEFINE> 
 DEFINE>{* Remove non-polar hydrogens? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} delenph=true; 
 DEFINE> 
 DEFINE>{* HADDOCK directory *} 
 DEFINE>{*  the absolute path of the HADDOCK program files *} 
 DEFINE>{===>} haddock_dir=/home/enmr/software/haddock2.4; 
 DEFINE> 
 DEFINE>{* Logfile directory *} 
 DEFINE>{* specify a directory for the large CNS log files *} 
 DEFINE>{===>} temptrash_dir=/home/enmr/csb_webserver/data/runs/haddock24/userrun00188213/run1; 
 DEFINE> 
 DEFINE>{==================== histidine patches =====================} 
 DEFINE> 
 DEFINE> 
 DEFINE>{==================== histidine patches =====================} 
 DEFINE>{* Automatically define histidine protonation state based on energetics *} 
 DEFINE>{===>} autohis=false; 
 DEFINE> 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HD1) *} 
 DEFINE>{* just give the residue number of the histidines for the HISD patch, set them to zero if you don't want them *} 
 DEFINE> 
 DEFINE>{* Number of HISD for molecule 1 *} 
 DEFINE>numhisd_1=4; 
 DEFINE>{===>} hisd_1_1=474; 
 DEFINE> 
 DEFINE>{===>} hisd_1_2=514; 
 DEFINE> 
 DEFINE>{===>} hisd_1_3=615; 
 DEFINE> 
 DEFINE>{===>} hisd_1_4=697; 
 DEFINE> 
 DEFINE>{* Number of HISD for molecule 5 *} 
 DEFINE>numhisd_2=0; 
 DEFINE> 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HE2) *} 
 DEFINE>{* just give the residue number of the histidines for the HISE patch, set them to zero if you don't want them *} 
 DEFINE> 
 DEFINE>{* Number of HISE for molecule 1 *} 
 DEFINE>numhise_1=6; 
 DEFINE>{===>} hise_1_1=449; 
 DEFINE> 
 DEFINE>{===>} hise_1_2=483; 
 DEFINE> 
 DEFINE>{===>} hise_1_3=498; 
 DEFINE> 
 DEFINE>{===>} hise_1_4=604; 
 DEFINE> 
 DEFINE>{===>} hise_1_5=654; 
 DEFINE> 
 DEFINE>{===>} hise_1_6=695; 
 DEFINE> 
 DEFINE>{* Number of HISE for molecule 7 *} 
 DEFINE>numhise_2=0; 
 DEFINE> 
 DEFINE>{========= Definition of semi-flexible interface ============} 
 DEFINE>{* Define the interface of each molecule.*} 
 DEFINE>{* Side-chains and backbone of these residues will be allowed to move during semi-flexible refinement*} 
 DEFINE>{* Distance cutoff in A for the automatic definition of flexible segments based on intermolecular residues contacts *} 
 DEFINE>{===>} flcut_nb=5.0; 
 DEFINE>{* number of semi-flexible segments for molecule  1 (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_1=-1; 
 DEFINE>{* number of semi-flexible segments for molecule  2 (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_2=-1; 
 DEFINE> 
 DEFINE>{=========== Definition of fully flexible segments ==========} 
 DEFINE>{* Define the fully flexible segment of each molecule.*} 
 DEFINE>{* These segments will be allowed to move at all stages of it1 *} 
 DEFINE> 
 DEFINE> 
 DEFINE>{* Number of fully flexible segments for molecule  1            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_1=0; 
 DEFINE>{* Number of fully flexible segments for molecule  2            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_2=0; 
 DEFINE> 
 DEFINE>{==================== membrane positioning restraints  ==================} 
 DEFINE>{* Do you want to use membrane positioning restraints ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} zres_on=false; 
 DEFINE> 
 DEFINE>{* Number of membrane positioning restrained segments *} 
 DEFINE>{===>} numzres=0; 
 DEFINE> 
 DEFINE>{====================== NCS restraints  =====================} 
 DEFINE>{* Do you want to use NCS restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ncs_on=false; 
 DEFINE> 
 DEFINE>{* Number of NCS pairs *} 
 DEFINE>{===>} numncs=0; 
 DEFINE> 
 DEFINE>{==================== Symmetry restraints  ==================} 
 DEFINE>{* Do you want to use symmetry restraints ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} sym_on=false; 
 DEFINE> 
 DEFINE>{* Force constant for symmetry restraints ? *} 
 DEFINE>{===>} ksym=10.0; 
 DEFINE>{* Number of C2 symmetry pairs *} 
 DEFINE>{===>} numc2sym=0; 
 DEFINE>{* Number of C3 symmetry triples*} 
 DEFINE>{===>} numc3sym=0; 
 DEFINE>{* Number of S3 symmetry triples*} 
 DEFINE>{===>} nums3sym=0; 
 DEFINE>{* Number of C4 symmetry quadruples *} 
 DEFINE>{===>} numc4sym=0; 
 DEFINE>{* Number of C5 symmetry *} 
 DEFINE>{===>} numc5sym=0; 
 DEFINE> 
 DEFINE>{* Number of c6 symmetry *} 
 DEFINE>{===>} numc6sym=0; 
 DEFINE> 
 DEFINE>{=========================== Distance restraints  ========================} 
 DEFINE>{* Turn on/off and energy constants for distance restraints *} 
 DEFINE>{+ table: rows=3 "distances" "AIR (ambig)" "hbonds" cols=6 "firstIteration" "lastIteration" "hot" "cool1" "cool2" "cool3"+} 
 DEFINE> 
 DEFINE>{===>} unamb_firstit=0; 
 DEFINE>{===>} unamb_lastit=2; 
 DEFINE>{===>} unamb_hot=10.0; 
 DEFINE>{===>} unamb_cool1=10.0; 
 DEFINE>{===>} unamb_cool2=50.0; 
 DEFINE>{===>} unamb_cool3=50.0; 
 DEFINE>{===>} amb_firstit=0; 
 DEFINE>{===>} amb_lastit=2; 
 DEFINE>{===>} amb_hot=10.0; 
 DEFINE>{===>} amb_cool1=10.0; 
 DEFINE>{===>} amb_cool2=50.0; 
 DEFINE>{===>} amb_cool3=50.0; 
 DEFINE>{===>} hbond_firstit=0; 
 DEFINE>{===>} hbond_lastit=2; 
 DEFINE>{===>} hbond_hot=10.0; 
 DEFINE>{===>} hbond_cool1=10.0; 
 DEFINE>{===>} hbond_cool2=50.0; 
 DEFINE>{===>} hbond_cool3=50.0; 
 DEFINE> 
 DEFINE>{* Do you want to randomly exclude a fraction of the ambiguous restraints (AIRs)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} noecv=true; 
 DEFINE> 
 DEFINE>{* Number of partitions for random exclusion (%excluded=100/number of partitions)? *} 
 DEFINE>{===>} ncvpart=2.0000; 
 DEFINE> 
 DEFINE>{* Do you want to use hydrogen bond restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} hbonds_on=false; 
 DEFINE> 
 DEFINE>{* Do you want to define randomly ambiguous interaction restraints from accessible residues? *} 
 DEFINE>{* Only residues in the defined flexible segments will be considered *} 
 DEFINE>{* Note that this option is exclusive with any other distance restraints and only for it0    *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ranair=false; 
 DEFINE> 
 DEFINE>{* Do you want to define center of mass restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cmrest=true; 
 DEFINE> 
 DEFINE>{* Define tight CM restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cmtight=true; 
 DEFINE> 
 DEFINE>{* Force constant for center of mass restraints *} 
 DEFINE>{===>} kcont=1.0; 
 DEFINE> 
 DEFINE>{* Do you want to define surface contact restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} surfrest=true; 
 DEFINE> 
 DEFINE>{* Force constant for surface contact restraints *} 
 DEFINE>{===>} ksurf=1.0; 
 DEFINE> 
 DEFINE>{ Use automated distance restraints weighting } 
 DEFINE>{ choice: true false } 
 DEFINE>air_scaling=false; 
 DEFINE>{ Define the number of distance restraints for automated weighting } 
 DEFINE>tot_unamb=25; 
 DEFINE>{ Define the number of AIR restraints for automated weighting } 
 DEFINE>tot_amb=0; 
 DEFINE>{ potential shape } 
 DEFINE>mrswi_hot=0.5; 
 DEFINE>mrswi_cool1=0.5; 
 DEFINE>mrswi_cool2=0.5; 
 DEFINE>mrswi_cool3=0.5; 
 DEFINE>rswi_hot=0.5; 
 DEFINE>rswi_cool1=0.5; 
 DEFINE>rswi_cool2=0.5; 
 DEFINE>rswi_cool3=0.5; 
 DEFINE>masy_hot=-1.0; 
 DEFINE>masy_cool1=-1.0; 
 DEFINE>masy_cool2=-0.1; 
 DEFINE>masy_cool3=-0.1; 
 DEFINE>asy_hot=1.0; 
 DEFINE>asy_cool1=1.0; 
 DEFINE>asy_cool2=0.1; 
 DEFINE>asy_cool3=0.1; 
 DEFINE> 
 DEFINE>{=========================== radius of gyration restraint  ============} 
 DEFINE>{* Turn on/off and energy constants for Rg restraints *} 
 DEFINE>{* Do you want to define a radius of gyration restraint (e.g. from SAXS)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rgrest=false; 
 DEFINE> 
 DEFINE> 
 DEFINE>{======================DNA-RNA restraints ============================} 
 DEFINE>{* Use DNA/RNA restraints (dna-rna_restraints.def in data/sequence)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dnarest_on=false; 
 DEFINE> 
 DEFINE>{=========================== dihedrals restraints ====================} 
 DEFINE>{* energy constants *} 
 DEFINE>{+ table: rows=1 "dihedrals" cols=5 "use?" "hot" "cool1" "cool2" "cool3" +} 
 DEFINE> 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dihedrals_on=false; 
 DEFINE>{===>} dihedrals_hot=5.0; 
 DEFINE>{===>} dihedrals_cool1=5.0; 
 DEFINE>{===>} dihedrals_cool2=50.0; 
 DEFINE>{===>} dihedrals_cool3=200.0; 
 DEFINE> 
 DEFINE>{* Automatically define backbone dihedral angle restraints from structure? *} 
 DEFINE>{+ choice: none all alpha alphabeta +} 
 DEFINE>{===>} ssdihed=alphabeta; 
 DEFINE>{===>} error_dih=10; 
 DEFINE> 
 DEFINE>{=========================== residual dipolar couplings ======================} 
 DEFINE> 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=25 "type" "firstIt" "lastIt" "Ksani<br>(hot)" "Ksani<br>(cool1)" "Ksani<br>(cool2)" "Ksani<br>(cool3)" "R" "D" 
 DEFINE> "Kvean<br>(ini_bor_hot)" "Kvean<br>(fin_bor_hot)" 
 DEFINE> "Kvean<br>(ini_bor_cool1)" "Kvean<br>(fin_bor_cool1)" 
 DEFINE> "Kvean<br>(ini_bor_cool2)" "Kvean<br>(fin_bor_cool2)" 
 DEFINE> "Kvean<br>(ini_bor_cool3)" "Kvean<br>(fin_bor_cool3)" 
 DEFINE> "Kvean<br>(ini_cen_hot)" "Kvean<br>(fin_cen_hot)" 
 DEFINE> "Kvean<br>(ini_cen_cool1)" "Kvean<br>(fin_cen_cool1)" 
 DEFINE> "Kvean<br>(ini_cen_cool2)" "Kvean<br>(fin_cen_cool2)" 
 DEFINE> "Kvean<br>(ini_cen_cool3)" "Kvean<br>(fin_cen_cool3)"+} 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} numrdc = 0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{=========================== pseudo contact shifts ===========================} 
 DEFINE> 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=10 "class1" "class2" "class3" "class4" "class5" "class6" "class7" "class8" "class9" "class10" 
 DEFINE>          cols=9 "type" "firstIt" "lastIt" "Kpcs<br>(hot)" "Kpcs<br>(cool1)" "Kpcs<br>(cool2)" "Kpcs<br>(cool3)" "R" "D" +} 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} numpcs = 0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{=========================== relaxation data ======================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=12 "type" "firstIt" "lastIt" "Kdani(hot)" "Kdani(cool1)" "Kdani(cool2)" "Kdani(cool3)" "Correlation time" "D" "R" "H frequency" "N frequency" +} 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} numdani = 0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{========================== Cryo-EM parameters ============================} 
 DEFINE> 
 DEFINE>{* Centroid definitions *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} centroid_rest=false; 
 DEFINE>{===>} centroid_kscale=50; 
 DEFINE> 
 DEFINE> 
 DEFINE>{* Density/XREF restraints *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_rest=false; 
 DEFINE>{===>} em_kscale=15000; 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_it0=false; 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_it1=false; 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_itw=false; 
 DEFINE> 
 DEFINE>{* Resolution of data in angstrom *} 
 DEFINE>{===>} em_resolution=None; 
 DEFINE> 
 DEFINE>{* Density parameters *} 
 DEFINE>{* Number of voxels in each dimension *} 
 DEFINE>{===>} nx=32; 
 DEFINE>{===>} ny=32; 
 DEFINE>{===>} nz=32; 
 DEFINE> 
 DEFINE>{* Length of each dimension in angstrom *} 
 DEFINE>{===>} xlength=80.0; 
 DEFINE>{===>} ylength=80.0; 
 DEFINE>{===>} zlength=80.0; 
 DEFINE> 
 DEFINE>{* Cryo-EM scoring weights *} 
 DEFINE>{===>} w_lcc_0=-400.0; 
 DEFINE>{===>} w_lcc_1=-10000.0; 
 DEFINE>{===>} w_lcc_2=-10000.0; 
 DEFINE> 
 DEFINE>{===================== topology and parameter files ======================} 
 DEFINE> 
 DEFINE>{* topology file for molecule  1 *} 
 DEFINE>{===>} prot_top_mol1="protein-allhdg5-4.top"; 
 DEFINE>{* linkage file for molecule  1 *} 
 DEFINE>{===>} prot_link_mol1="protein-allhdg5-4-noter.link"; 
 DEFINE>{* energy parameter file for molecule  1 *} 
 DEFINE>{===>} prot_par_mol1="protein-allhdg5-4.param"; 
 DEFINE>{* topology file for molecule  2 *} 
 DEFINE>{===>} prot_top_mol2="protein-allhdg5-4.top"; 
 DEFINE>{* linkage file for molecule  2 *} 
 DEFINE>{===>} prot_link_mol2="protein-allhdg5-4-noter.link"; 
 DEFINE>{* energy parameter file for molecule  2 *} 
 DEFINE>{===>} prot_par_mol2="protein-allhdg5-4.param"; 
 DEFINE> 
 DEFINE>{* type of non-bonded parameters *} 
 DEFINE>{* specify the type of non-bonded interaction *} 
 DEFINE>{+ choice: "PROLSQ" "PARMALLH6" "PARALLHDG" "OPLSX" +} 
 DEFINE>{===>} par_nonbonded="OPLSX"; 
 DEFINE> 
 DEFINE>{============coarse graining topology and parameter files ==================} 
 DEFINE> 
 DEFINE>{* topology file for molecule  1 *} 
 DEFINE>{===>} prot_cg_top_mol1="protein-CG-Martini-2-2.top"; 
 DEFINE>{* linkage file for molecule  1 *} 
 DEFINE>{===>} prot_cg_link_mol1="protein-CG-Martini-2-2.link"; 
 DEFINE>{* energy parameter file for molecule  1 *} 
 DEFINE>{===>} prot_cg_par_mol1="protein-CG-Martini-2-2.param"; 
 DEFINE>{* topology file for molecule  2 *} 
 DEFINE>{===>} prot_cg_top_mol2="protein-CG-Martini-2-2.top"; 
 DEFINE>{* linkage file for molecule  2 *} 
 DEFINE>{===>} prot_cg_link_mol2="protein-CG-Martini-2-2.link"; 
 DEFINE>{* energy parameter file for molecule  2 *} 
 DEFINE>{===>} prot_cg_par_mol2="protein-CG-Martini-2-2.param"; 
 DEFINE> 
 DEFINE>{===================== energy and interaction parameters ==================} 
 DEFINE> 
 DEFINE>{ Do you want to include dihedral angle energy terms? } 
 DEFINE>{ choice: true false } 
 DEFINE>dihedflag=true; 
 DEFINE> 
 DEFINE>{* Do you want to include the electrostatic energy term for docking? *} 
 DEFINE>{* Note that it will be automatically included in the solvent refinement *} 
 DEFINE> 
 DEFINE>{* Include electrostatic during rigid body docking (it0)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_0=true; 
 DEFINE>{* Include electrostatic during semi-flexible SA (it1)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_1=true; 
 DEFINE> 
 DEFINE>{* Give the epsilon constant for the electrostatic energy term in it0 *} 
 DEFINE>{* Note that for explicit solvent refinement cdie with epsilon=1 is used *} 
 DEFINE>{===>} epsilon_0=10.0; 
 DEFINE> 
 DEFINE>{* Give the epsilon constant for the electrostatic energy term in it1 *} 
 DEFINE>{* Note that for explicit solvent refinement cdie with epsilon=1 is used *} 
 DEFINE>{===>} epsilon_1=1.0; 
 DEFINE> 
 DEFINE>{* Use constant (cdie) or distance-dependent (rdie) dielectric in it0? *} 
 DEFINE>{+ choice: cdie rdie +} 
 DEFINE>{===>} dielec_0=rdie; 
 DEFINE> 
 DEFINE>{* Use constant (cdie) or distance-dependent (rdie) dielectric in it1? *} 
 DEFINE>{+ choice: cdie rdie +} 
 DEFINE>{===>} dielec_1=rdie; 
 DEFINE> 
 DEFINE>{* Scaling of intermolecular interactions for rigid body EM*} 
 DEFINE>{===>} inter_rigid=1.0; 
 DEFINE> 
 DEFINE>{* Scaling of intermolecular interactions for semi-flexible SA*} 
 DEFINE>{+ table: rows=3 "Rigid body dynamic " "SA with flexible side-chains (cool2)" "SA with flexible backbone and side-chains (cool3)" 
 DEFINE>          cols=2 "Init value" "Final value" +} 
 DEFINE>{===>} init_rigid=0.001; 
 DEFINE>{===>} fin_rigid=0.001; 
 DEFINE>{===>} init_cool2=0.001; 
 DEFINE>{===>} fin_cool2=1.0; 
 DEFINE>{===>} init_cool3=0.05; 
 DEFINE>{===>} fin_cool3=1.0; 
 DEFINE> 
 DEFINE>{* Interaction matrix for non-bonded interactions*} 
 DEFINE>{+ table: rows=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" "Mol 7" "Mol 8" "Mol 9" Mol 10" "Mol 11" Mol 12" "Mol 13" "Mol 14" "Mol 15" "Mol 16" "Mol 17" "Mol 18" "Mol 19" "Mol 20" 
 DEFINE>          cols=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" "Mol 7" "Mol 8" "Mol 9" Mol 10" "Mol 11" Mol 12" "Mol 13" "Mol 14" "Mol 15" "Mol 16" "Mol 17" "Mol 18" "Mol 19" "Mol 20" +} 
 DEFINE>{===>} int_1_1=1.0; 
 DEFINE>{===>} int_1_2=1.0; 
 DEFINE>{===>} int_1_3=1.0; 
 DEFINE>{===>} int_1_4=1.0; 
 DEFINE>{===>} int_1_5=1.0; 
 DEFINE>{===>} int_1_6=1.0; 
 DEFINE>{===>} int_1_7=1.0; 
 DEFINE>{===>} int_1_8=1.0; 
 DEFINE>{===>} int_1_9=1.0; 
 DEFINE>{===>} int_1_10=1.0; 
 DEFINE>{===>} int_1_11=1.0; 
 DEFINE>{===>} int_1_12=1.0; 
 DEFINE>{===>} int_1_13=1.0; 
 DEFINE>{===>} int_1_14=1.0; 
 DEFINE>{===>} int_1_15=1.0; 
 DEFINE>{===>} int_1_16=1.0; 
 DEFINE>{===>} int_1_17=1.0; 
 DEFINE>{===>} int_1_18=1.0; 
 DEFINE>{===>} int_1_19=1.0; 
 DEFINE>{===>} int_1_20=1.0; 
 DEFINE>{===>} int_2_1="N.A."; 
 DEFINE>{===>} int_2_2=1.0; 
 DEFINE>{===>} int_2_3=1.0; 
 DEFINE>{===>} int_2_4=1.0; 
 DEFINE>{===>} int_2_5=1.0; 
 DEFINE>{===>} int_2_6=1.0; 
 DEFINE>{===>} int_2_7=1.0; 
 DEFINE>{===>} int_2_8=1.0; 
 DEFINE>{===>} int_2_9=1.0; 
 DEFINE>{===>} int_2_10=1.0; 
 DEFINE>{===>} int_2_11=1.0; 
 DEFINE>{===>} int_2_12=1.0; 
 DEFINE>{===>} int_2_13=1.0; 
 DEFINE>{===>} int_2_14=1.0; 
 DEFINE>{===>} int_2_15=1.0; 
 DEFINE>{===>} int_2_16=1.0; 
 DEFINE>{===>} int_2_17=1.0; 
 DEFINE>{===>} int_2_18=1.0; 
 DEFINE>{===>} int_2_19=1.0; 
 DEFINE>{===>} int_2_20=1.0; 
 DEFINE>{===>} int_3_1="N.A."; 
 DEFINE>{===>} int_3_2="N.A."; 
 DEFINE>{===>} int_3_3=1.0; 
 DEFINE>{===>} int_3_4=1.0; 
 DEFINE>{===>} int_3_5=1.0; 
 DEFINE>{===>} int_3_6=1.0; 
 DEFINE>{===>} int_3_7=1.0; 
 DEFINE>{===>} int_3_8=1.0; 
 DEFINE>{===>} int_3_9=1.0; 
 DEFINE>{===>} int_3_10=1.0; 
 DEFINE>{===>} int_3_11=1.0; 
 DEFINE>{===>} int_3_12=1.0; 
 DEFINE>{===>} int_3_13=1.0; 
 DEFINE>{===>} int_3_14=1.0; 
 DEFINE>{===>} int_3_15=1.0; 
 DEFINE>{===>} int_3_16=1.0; 
 DEFINE>{===>} int_3_17=1.0; 
 DEFINE>{===>} int_3_18=1.0; 
 DEFINE>{===>} int_3_19=1.0; 
 DEFINE>{===>} int_3_20=1.0; 
 DEFINE>{===>} int_4_1="N.A."; 
 DEFINE>{===>} int_4_2="N.A."; 
 DEFINE>{===>} int_4_3="N.A."; 
 DEFINE>{===>} int_4_4=1.0; 
 DEFINE>{===>} int_4_5=1.0; 
 DEFINE>{===>} int_4_6=1.0; 
 DEFINE>{===>} int_4_7=1.0; 
 DEFINE>{===>} int_4_8=1.0; 
 DEFINE>{===>} int_4_9=1.0; 
 DEFINE>{===>} int_4_10=1.0; 
 DEFINE>{===>} int_4_11=1.0; 
 DEFINE>{===>} int_4_12=1.0; 
 DEFINE>{===>} int_4_13=1.0; 
 DEFINE>{===>} int_4_14=1.0; 
 DEFINE>{===>} int_4_15=1.0; 
 DEFINE>{===>} int_4_16=1.0; 
 DEFINE>{===>} int_4_17=1.0; 
 DEFINE>{===>} int_4_18=1.0; 
 DEFINE>{===>} int_4_19=1.0; 
 DEFINE>{===>} int_4_20=1.0; 
 DEFINE>{===>} int_5_1="N.A."; 
 DEFINE>{===>} int_5_2="N.A."; 
 DEFINE>{===>} int_5_3="N.A."; 
 DEFINE>{===>} int_5_4="N.A."; 
 DEFINE>{===>} int_5_5=1.0; 
 DEFINE>{===>} int_5_6=1.0; 
 DEFINE>{===>} int_5_7=1.0; 
 DEFINE>{===>} int_5_8=1.0; 
 DEFINE>{===>} int_5_9=1.0; 
 DEFINE>{===>} int_5_10=1.0; 
 DEFINE>{===>} int_5_11=1.0; 
 DEFINE>{===>} int_5_12=1.0; 
 DEFINE>{===>} int_5_13=1.0; 
 DEFINE>{===>} int_5_14=1.0; 
 DEFINE>{===>} int_5_15=1.0; 
 DEFINE>{===>} int_5_16=1.0; 
 DEFINE>{===>} int_5_17=1.0; 
 DEFINE>{===>} int_5_18=1.0; 
 DEFINE>{===>} int_5_19=1.0; 
 DEFINE>{===>} int_5_20=1.0; 
 DEFINE>{===>} int_6_1="N.A."; 
 DEFINE>{===>} int_6_2="N.A."; 
 DEFINE>{===>} int_6_3="N.A."; 
 DEFINE>{===>} int_6_4="N.A."; 
 DEFINE>{===>} int_6_5="N.A."; 
 DEFINE>{===>} int_6_6=1.0; 
 DEFINE>{===>} int_6_7=1.0; 
 DEFINE>{===>} int_6_8=1.0; 
 DEFINE>{===>} int_6_9=1.0; 
 DEFINE>{===>} int_6_10=1.0; 
 DEFINE>{===>} int_6_11=1.0; 
 DEFINE>{===>} int_6_12=1.0; 
 DEFINE>{===>} int_6_13=1.0; 
 DEFINE>{===>} int_6_14=1.0; 
 DEFINE>{===>} int_6_15=1.0; 
 DEFINE>{===>} int_6_16=1.0; 
 DEFINE>{===>} int_6_17=1.0; 
 DEFINE>{===>} int_6_18=1.0; 
 DEFINE>{===>} int_6_19=1.0; 
 DEFINE>{===>} int_6_20=1.0; 
 DEFINE>{===>} int_7_1="N.A."; 
 DEFINE>{===>} int_7_2="N.A."; 
 DEFINE>{===>} int_7_3="N.A."; 
 DEFINE>{===>} int_7_4="N.A."; 
 DEFINE>{===>} int_7_5="N.A."; 
 DEFINE>{===>} int_7_6="N.A."; 
 DEFINE>{===>} int_7_7=1.0; 
 DEFINE>{===>} int_7_8=1.0; 
 DEFINE>{===>} int_7_9=1.0; 
 DEFINE>{===>} int_7_10=1.0; 
 DEFINE>{===>} int_7_11=1.0; 
 DEFINE>{===>} int_7_12=1.0; 
 DEFINE>{===>} int_7_13=1.0; 
 DEFINE>{===>} int_7_14=1.0; 
 DEFINE>{===>} int_7_15=1.0; 
 DEFINE>{===>} int_7_16=1.0; 
 DEFINE>{===>} int_7_17=1.0; 
 DEFINE>{===>} int_7_18=1.0; 
 DEFINE>{===>} int_7_19=1.0; 
 DEFINE>{===>} int_7_20=1.0; 
 DEFINE>{===>} int_8_1="N.A."; 
 DEFINE>{===>} int_8_2="N.A."; 
 DEFINE>{===>} int_8_3="N.A."; 
 DEFINE>{===>} int_8_4="N.A."; 
 DEFINE>{===>} int_8_5="N.A."; 
 DEFINE>{===>} int_8_6="N.A."; 
 DEFINE>{===>} int_8_7="N.A."; 
 DEFINE>{===>} int_8_8=1.0; 
 DEFINE>{===>} int_8_9=1.0; 
 DEFINE>{===>} int_8_10=1.0; 
 DEFINE>{===>} int_8_11=1.0; 
 DEFINE>{===>} int_8_12=1.0; 
 DEFINE>{===>} int_8_13=1.0; 
 DEFINE>{===>} int_8_14=1.0; 
 DEFINE>{===>} int_8_15=1.0; 
 DEFINE>{===>} int_8_16=1.0; 
 DEFINE>{===>} int_8_17=1.0; 
 DEFINE>{===>} int_8_18=1.0; 
 DEFINE>{===>} int_8_19=1.0; 
 DEFINE>{===>} int_8_20=1.0; 
 DEFINE>{===>} int_9_1="N.A."; 
 DEFINE>{===>} int_9_2="N.A."; 
 DEFINE>{===>} int_9_3="N.A."; 
 DEFINE>{===>} int_9_4="N.A."; 
 DEFINE>{===>} int_9_5="N.A."; 
 DEFINE>{===>} int_9_6="N.A."; 
 DEFINE>{===>} int_9_7="N.A."; 
 DEFINE>{===>} int_9_8="N.A."; 
 DEFINE>{===>} int_9_9=1.0; 
 DEFINE>{===>} int_9_10=1.0; 
 DEFINE>{===>} int_9_11=1.0; 
 DEFINE>{===>} int_9_12=1.0; 
 DEFINE>{===>} int_9_13=1.0; 
 DEFINE>{===>} int_9_14=1.0; 
 DEFINE>{===>} int_9_15=1.0; 
 DEFINE>{===>} int_9_16=1.0; 
 DEFINE>{===>} int_9_17=1.0; 
 DEFINE>{===>} int_9_18=1.0; 
 DEFINE>{===>} int_9_19=1.0; 
 DEFINE>{===>} int_9_20=1.0; 
 DEFINE>{===>} int_10_1="N.A."; 
 DEFINE>{===>} int_10_2="N.A."; 
 DEFINE>{===>} int_10_3="N.A."; 
 DEFINE>{===>} int_10_4="N.A."; 
 DEFINE>{===>} int_10_5="N.A."; 
 DEFINE>{===>} int_10_6="N.A."; 
 DEFINE>{===>} int_10_7="N.A."; 
 DEFINE>{===>} int_10_8="N.A."; 
 DEFINE>{===>} int_10_9="N.A."; 
 DEFINE>{===>} int_10_10=1.0; 
 DEFINE>{===>} int_10_11=1.0; 
 DEFINE>{===>} int_10_12=1.0; 
 DEFINE>{===>} int_10_13=1.0; 
 DEFINE>{===>} int_10_14=1.0; 
 DEFINE>{===>} int_10_15=1.0; 
 DEFINE>{===>} int_10_16=1.0; 
 DEFINE>{===>} int_10_17=1.0; 
 DEFINE>{===>} int_10_18=1.0; 
 DEFINE>{===>} int_10_19=1.0; 
 DEFINE>{===>} int_10_20=1.0; 
 DEFINE>{===>} int_11_1="N.A."; 
 DEFINE>{===>} int_11_2="N.A."; 
 DEFINE>{===>} int_11_3="N.A."; 
 DEFINE>{===>} int_11_4="N.A."; 
 DEFINE>{===>} int_11_5="N.A."; 
 DEFINE>{===>} int_11_6="N.A."; 
 DEFINE>{===>} int_11_7="N.A."; 
 DEFINE>{===>} int_11_8="N.A."; 
 DEFINE>{===>} int_11_9="N.A."; 
 DEFINE>{===>} int_11_10="N.A."; 
 DEFINE>{===>} int_11_11=1.0; 
 DEFINE>{===>} int_11_12=1.0; 
 DEFINE>{===>} int_11_13=1.0; 
 DEFINE>{===>} int_11_14=1.0; 
 DEFINE>{===>} int_11_15=1.0; 
 DEFINE>{===>} int_11_16=1.0; 
 DEFINE>{===>} int_11_17=1.0; 
 DEFINE>{===>} int_11_18=1.0; 
 DEFINE>{===>} int_11_19=1.0; 
 DEFINE>{===>} int_11_20=1.0; 
 DEFINE>{===>} int_12_1="N.A."; 
 DEFINE>{===>} int_12_2="N.A."; 
 DEFINE>{===>} int_12_3="N.A."; 
 DEFINE>{===>} int_12_4="N.A."; 
 DEFINE>{===>} int_12_5="N.A."; 
 DEFINE>{===>} int_12_6="N.A."; 
 DEFINE>{===>} int_12_7="N.A."; 
 DEFINE>{===>} int_12_8="N.A."; 
 DEFINE>{===>} int_12_9="N.A."; 
 DEFINE>{===>} int_12_10="N.A."; 
 DEFINE>{===>} int_12_11="N.A."; 
 DEFINE>{===>} int_12_12=1.0; 
 DEFINE>{===>} int_12_13=1.0; 
 DEFINE>{===>} int_12_14=1.0; 
 DEFINE>{===>} int_12_15=1.0; 
 DEFINE>{===>} int_12_16=1.0; 
 DEFINE>{===>} int_12_17=1.0; 
 DEFINE>{===>} int_12_18=1.0; 
 DEFINE>{===>} int_12_19=1.0; 
 DEFINE>{===>} int_12_20=1.0; 
 DEFINE>{===>} int_13_1="N.A."; 
 DEFINE>{===>} int_13_2="N.A."; 
 DEFINE>{===>} int_13_3="N.A."; 
 DEFINE>{===>} int_13_4="N.A."; 
 DEFINE>{===>} int_13_5="N.A."; 
 DEFINE>{===>} int_13_6="N.A."; 
 DEFINE>{===>} int_13_7="N.A."; 
 DEFINE>{===>} int_13_8="N.A."; 
 DEFINE>{===>} int_13_9="N.A."; 
 DEFINE>{===>} int_13_10="N.A."; 
 DEFINE>{===>} int_13_11="N.A."; 
 DEFINE>{===>} int_13_12="N.A."; 
 DEFINE>{===>} int_13_13=1.0; 
 DEFINE>{===>} int_13_14=1.0; 
 DEFINE>{===>} int_13_15=1.0; 
 DEFINE>{===>} int_13_16=1.0; 
 DEFINE>{===>} int_13_17=1.0; 
 DEFINE>{===>} int_13_18=1.0; 
 DEFINE>{===>} int_13_19=1.0; 
 DEFINE>{===>} int_13_20=1.0; 
 DEFINE>{===>} int_14_1="N.A."; 
 DEFINE>{===>} int_14_2="N.A."; 
 DEFINE>{===>} int_14_3="N.A."; 
 DEFINE>{===>} int_14_4="N.A."; 
 DEFINE>{===>} int_14_5="N.A."; 
 DEFINE>{===>} int_14_6="N.A."; 
 DEFINE>{===>} int_14_7="N.A."; 
 DEFINE>{===>} int_14_8="N.A."; 
 DEFINE>{===>} int_14_9="N.A."; 
 DEFINE>{===>} int_14_10="N.A."; 
 DEFINE>{===>} int_14_11="N.A."; 
 DEFINE>{===>} int_14_12="N.A."; 
 DEFINE>{===>} int_14_13="N.A."; 
 DEFINE>{===>} int_14_14=1.0; 
 DEFINE>{===>} int_14_15=1.0; 
 DEFINE>{===>} int_14_16=1.0; 
 DEFINE>{===>} int_14_17=1.0; 
 DEFINE>{===>} int_14_18=1.0; 
 DEFINE>{===>} int_14_19=1.0; 
 DEFINE>{===>} int_14_20=1.0; 
 DEFINE>{===>} int_15_1="N.A."; 
 DEFINE>{===>} int_15_2="N.A."; 
 DEFINE>{===>} int_15_3="N.A."; 
 DEFINE>{===>} int_15_4="N.A."; 
 DEFINE>{===>} int_15_5="N.A."; 
 DEFINE>{===>} int_15_6="N.A."; 
 DEFINE>{===>} int_15_7="N.A."; 
 DEFINE>{===>} int_15_8="N.A."; 
 DEFINE>{===>} int_15_9="N.A."; 
 DEFINE>{===>} int_15_10="N.A."; 
 DEFINE>{===>} int_15_11="N.A."; 
 DEFINE>{===>} int_15_12="N.A."; 
 DEFINE>{===>} int_15_13="N.A."; 
 DEFINE>{===>} int_15_14="N.A."; 
 DEFINE>{===>} int_15_15=1.0; 
 DEFINE>{===>} int_15_16=1.0; 
 DEFINE>{===>} int_15_17=1.0; 
 DEFINE>{===>} int_15_18=1.0; 
 DEFINE>{===>} int_15_19=1.0; 
 DEFINE>{===>} int_15_20=1.0; 
 DEFINE>{===>} int_16_1="N.A."; 
 DEFINE>{===>} int_16_2="N.A."; 
 DEFINE>{===>} int_16_3="N.A."; 
 DEFINE>{===>} int_16_4="N.A."; 
 DEFINE>{===>} int_16_5="N.A."; 
 DEFINE>{===>} int_16_6="N.A."; 
 DEFINE>{===>} int_16_7="N.A."; 
 DEFINE>{===>} int_16_8="N.A."; 
 DEFINE>{===>} int_16_9="N.A."; 
 DEFINE>{===>} int_16_10="N.A."; 
 DEFINE>{===>} int_16_11="N.A."; 
 DEFINE>{===>} int_16_12="N.A."; 
 DEFINE>{===>} int_16_13="N.A."; 
 DEFINE>{===>} int_16_14="N.A."; 
 DEFINE>{===>} int_16_15="N.A."; 
 DEFINE>{===>} int_16_16=1.0; 
 DEFINE>{===>} int_16_17=1.0; 
 DEFINE>{===>} int_16_18=1.0; 
 DEFINE>{===>} int_16_19=1.0; 
 DEFINE>{===>} int_16_20=1.0; 
 DEFINE>{===>} int_17_1="N.A."; 
 DEFINE>{===>} int_17_2="N.A."; 
 DEFINE>{===>} int_17_3="N.A."; 
 DEFINE>{===>} int_17_4="N.A."; 
 DEFINE>{===>} int_17_5="N.A."; 
 DEFINE>{===>} int_17_6="N.A."; 
 DEFINE>{===>} int_17_7="N.A."; 
 DEFINE>{===>} int_17_8="N.A."; 
 DEFINE>{===>} int_17_9="N.A."; 
 DEFINE>{===>} int_17_10="N.A."; 
 DEFINE>{===>} int_17_11="N.A."; 
 DEFINE>{===>} int_17_12="N.A."; 
 DEFINE>{===>} int_17_13="N.A."; 
 DEFINE>{===>} int_17_14="N.A."; 
 DEFINE>{===>} int_17_15="N.A."; 
 DEFINE>{===>} int_17_16="N.A."; 
 DEFINE>{===>} int_17_17=1.0; 
 DEFINE>{===>} int_17_18=1.0; 
 DEFINE>{===>} int_17_19=1.0; 
 DEFINE>{===>} int_17_20=1.0; 
 DEFINE>{===>} int_18_1="N.A."; 
 DEFINE>{===>} int_18_2="N.A."; 
 DEFINE>{===>} int_18_3="N.A."; 
 DEFINE>{===>} int_18_4="N.A."; 
 DEFINE>{===>} int_18_5="N.A."; 
 DEFINE>{===>} int_18_6="N.A."; 
 DEFINE>{===>} int_18_7="N.A."; 
 DEFINE>{===>} int_18_8="N.A."; 
 DEFINE>{===>} int_18_9="N.A."; 
 DEFINE>{===>} int_18_10="N.A."; 
 DEFINE>{===>} int_18_11="N.A."; 
 DEFINE>{===>} int_18_12="N.A."; 
 DEFINE>{===>} int_18_13="N.A."; 
 DEFINE>{===>} int_18_14="N.A."; 
 DEFINE>{===>} int_18_15="N.A."; 
 DEFINE>{===>} int_18_16="N.A."; 
 DEFINE>{===>} int_18_17="N.A."; 
 DEFINE>{===>} int_18_18=1.0; 
 DEFINE>{===>} int_18_19=1.0; 
 DEFINE>{===>} int_18_20=1.0; 
 DEFINE>{===>} int_19_1="N.A."; 
 DEFINE>{===>} int_19_2="N.A."; 
 DEFINE>{===>} int_19_3="N.A."; 
 DEFINE>{===>} int_19_4="N.A."; 
 DEFINE>{===>} int_19_5="N.A."; 
 DEFINE>{===>} int_19_6="N.A."; 
 DEFINE>{===>} int_19_7="N.A."; 
 DEFINE>{===>} int_19_8="N.A."; 
 DEFINE>{===>} int_19_9="N.A."; 
 DEFINE>{===>} int_19_10="N.A."; 
 DEFINE>{===>} int_19_11="N.A."; 
 DEFINE>{===>} int_19_12="N.A."; 
 DEFINE>{===>} int_19_13="N.A."; 
 DEFINE>{===>} int_19_14="N.A."; 
 DEFINE>{===>} int_19_15="N.A."; 
 DEFINE>{===>} int_19_16="N.A."; 
 DEFINE>{===>} int_19_17="N.A."; 
 DEFINE>{===>} int_19_18="N.A."; 
 DEFINE>{===>} int_19_19=1.0; 
 DEFINE>{===>} int_19_20=1.0; 
 DEFINE>{===>} int_20_1="N.A."; 
 DEFINE>{===>} int_20_2="N.A."; 
 DEFINE>{===>} int_20_3="N.A."; 
 DEFINE>{===>} int_20_4="N.A."; 
 DEFINE>{===>} int_20_5="N.A."; 
 DEFINE>{===>} int_20_6="N.A."; 
 DEFINE>{===>} int_20_7="N.A."; 
 DEFINE>{===>} int_20_8="N.A."; 
 DEFINE>{===>} int_20_9="N.A."; 
 DEFINE>{===>} int_20_10="N.A."; 
 DEFINE>{===>} int_20_11="N.A."; 
 DEFINE>{===>} int_20_12="N.A."; 
 DEFINE>{===>} int_20_13="N.A."; 
 DEFINE>{===>} int_20_14="N.A."; 
 DEFINE>{===>} int_20_15="N.A."; 
 DEFINE>{===>} int_20_16="N.A."; 
 DEFINE>{===>} int_20_17="N.A."; 
 DEFINE>{===>} int_20_18="N.A."; 
 DEFINE>{===>} int_20_19="N.A."; 
 DEFINE>{===>} int_20_20=1.0; 
 DEFINE> 
 DEFINE>{===================== Number of structures to dock =======================} 
 DEFINE>{* Setting for the rigid-body (it0) and semi-flexible refinement (it1) *} 
 DEFINE> 
 DEFINE>{* number of structures for rigid body docking *} 
 DEFINE>{===>} structures_0=200; 
 DEFINE>       keepstruct_0=&structures_0; 
 DEFINE>{* number of structures for refinement *} 
 DEFINE>{===>} structures_1=200; 
 DEFINE>       keepstruct_1=&structures_1; 
 DEFINE>       keepstruct_2=&structures_1; 
 DEFINE>{* number of structures to be analysed*} 
 DEFINE>{===>} anastruc_1=200; 
 DEFINE>       anastruc_0=&anastruc_1; 
 DEFINE>       anastruc_2=&anastruc_1; 
 DEFINE> 
 DEFINE>{* - *} 
 DEFINE> 
 DEFINE>{* Sampling of symmetry related solutions                       *} 
 DEFINE> 
 DEFINE>{* Sample 180 degrees rotated solutions during rigid body EM?   *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_it0=false; 
 DEFINE> 
 DEFINE>{* Sample 180 degrees rotated solutions during semi-flexible SA?*} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_it1=false; 
 DEFINE> 
 DEFINE> 
 DEFINE>{=========================== DOCKING protocol =============================} 
 DEFINE>{* Cross-dock all combinations in the ensembles of starting structures? *} 
 DEFINE>{* Turn off this option if you only want to dock structure 1 of ensemble A *} 
 DEFINE>{*   to structure 1 of ensemble B, structure 2 to structure 2, etc. *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} crossdock=false; 
 DEFINE> 
 DEFINE>{* Randomize starting orientations? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} randorien=false; 
 DEFINE> 
 DEFINE>{* Expand starting orientations? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} expand=false; 
 DEFINE> 
 DEFINE>{* Expansion percentage *} 
 DEFINE>{===>} expansion=0.4; 
 DEFINE> 
 DEFINE>{* Random rotation angle *} 
 DEFINE>{===>} randangle=6; 
 DEFINE> 
 DEFINE>{* Rebuild missing atoms in the context of the complex? (refinement mode) *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rebuildcplx=false; 
 DEFINE> 
 DEFINE>{* Perform initial rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidmini=false; 
 DEFINE> 
 DEFINE>{* Allow translation in rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidtrans=false; 
 DEFINE> 
 DEFINE>{* Number of trials for rigid body minimisation? *} 
 DEFINE>{===>} ntrials=5; 
 DEFINE> 
 DEFINE>{* initial seed for random number generator *} 
 DEFINE>{* change to get different initial velocities *} 
 DEFINE>{===>} iniseed=917; 
 DEFINE> 
 DEFINE>{* temperature for rigid body high temperature TAD *} 
 DEFINE>{===>} tadhigh_t=2000; 
 DEFINE> 
 DEFINE>{* initial temperature for rigid body first TAD cooling step *} 
 DEFINE>{===>} tadinit1_t=2000; 
 DEFINE> 
 DEFINE>{* final temperature after first cooling step *} 
 DEFINE>{===>} tadfinal1_t=500; 
 DEFINE> 
 DEFINE>{* initial temperature for second TAD cooling step with flexible side-chain at the inferface *} 
 DEFINE>{===>} tadinit2_t=1000; 
 DEFINE> 
 DEFINE>{* finale temperature after second cooling step *} 
 DEFINE>{===>} tadfinal2_t=50; 
 DEFINE> 
 DEFINE>{* initial temperature for third TAD cooling step with fully flexible interface *} 
 DEFINE>{===>} tadinit3_t=1000; 
 DEFINE> 
 DEFINE>{* finale temperature after third cooling step *} 
 DEFINE>{===>} tadfinal3_t=50; 
 DEFINE> 
 DEFINE>{* time step *} 
 DEFINE>{===>} timestep=0.002; 
 DEFINE>{* factor for timestep in TAD *} 
 DEFINE>{===>} tadfactor=8; 
 DEFINE> 
 DEFINE>{* Number of EM steps for translational minimisation? *} 
 DEFINE>{===>} emstepstrans=1000; 
 DEFINE> 
 DEFINE>{* number of MD steps for rigid body high temperature TAD *} 
 DEFINE>{===>} initiosteps=0; 
 DEFINE> 
 DEFINE>{* number of MD steps during first rigid body cooling stage *} 
 DEFINE>{===>} cool1_steps=0; 
 DEFINE> 
 DEFINE>{* number of MD steps during second cooling stage with flexible side-chains at interface *} 
 DEFINE>{===>} cool2_steps=0; 
 DEFINE> 
 DEFINE>{* number of MD steps during third cooling stage with fully flexible interface *} 
 DEFINE>{===>} cool3_steps=0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{======================= Solvated rigid body docking=======================} 
 DEFINE>{* perform solvated docking ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} waterdock=false; 
 DEFINE> 
 DEFINE>{* which method to use for solvating? *} 
 DEFINE>{* db: database-based (recommended), restraints: for restrained solvating to amino-acid most often forming 
 DEFINE>water mediated contacts and blank (""): for uniform waterlayer *} 
 DEFINE>{+ choice: "db" "restraints" "" +} 
 DEFINE>{===>} solvate_method="db"; 
 DEFINE> 
 DEFINE>{* which propensity database to use? *} 
 DEFINE>{* statistical: based on an analysis of water-mediated contacts in the PDB, kyte-doolittle: based on the Kyte-Doolittle hydrophobicity scalte *} 
 DEFINE>{+ choice: "statistical" "kytedoolittle" +} 
 DEFINE>{===>} db_method="kytedoolittle"; 
 DEFINE> 
 DEFINE>{* initial cutoff for restraints solvating method *} 
 DEFINE>{* all waters further away from a highly occuring water solvated residue will be removed in the generation 
 DEFINE>of the initial solvation shell *} 
 DEFINE>{===>} water_restraint_initial=5.0; 
 DEFINE> 
 DEFINE>{* cutoff for restraints solvating method *} 
 DEFINE>{* upper distance limit for defining distance restraints between water and amino-acids often found to be 
 DEFINE>involved in water-mediated contacts *} 
 DEFINE>{===>} water_restraint_cutoff=5.0; 
 DEFINE> 
 DEFINE>{* force constant for restrainted solvating method *} 
 DEFINE>{===>} water_restraint_scale=25.0; 
 DEFINE> 
 DEFINE>{* fraction of water to keep *} 
 DEFINE>{* this is the fraction of all interface water after the initial rigid body docking that will be kept 
 DEFINE>(note that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} water_tokeep=0.50; 
 DEFINE> 
 DEFINE>{* fraction of water around DNA to keep *} 
 DEFINE>{* this is the fraction of interface water involving DNA phoshpates after the initial rigid body docking that will be kept 
 DEFINE>(note that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} dnap_water_tokeep=0.75; 
 DEFINE> 
 DEFINE>{* random fraction to be added to the fraction of water to keep *} 
 DEFINE>{===>} water_randfrac=0.0; 
 DEFINE> 
 DEFINE>{* water-protein surface-cutoff *} 
 DEFINE>{* waters further away than this cutoff distance from any component of the complex will be removed *} 
 DEFINE>{===>} water_surfcutoff=8.0; 
 DEFINE> 
 DEFINE>{* do some water analysis *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} water_analysis=false; 
 DEFINE> 
 DEFINE>{* allows translation of water molecules during rigid-body docking, true or false: *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} transwater=true; 
 DEFINE> 
 DEFINE>{* number of different initial solvation shells to generate *} 
 DEFINE>{===>} waterensemble=1; 
 DEFINE> 
 DEFINE> 
 DEFINE>{==================== final explicit solvent refinement  ==================} 
 DEFINE>{* Do you want to refine your docking models in explicit solvent? *} 
 DEFINE>{+ choice: "yes" "no" +} 
 DEFINE>{===>} firstwater="yes"; 
 DEFINE> 
 DEFINE>{* Build explicit solvent shell? (Can be turned off the large molecules or when morphing CG to AA models) *} 
 DEFINE>{* Only EM will then be performed                                                                         *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} solvshell=true; 
 DEFINE> 
 DEFINE>{* Which solvent do you want to use? *} 
 DEFINE>{+ choice: "water" "dmso" +} 
 DEFINE>{===>} solvent="water"; 
 DEFINE> 
 DEFINE>{* number of structures for the explicit solvent refinement *} 
 DEFINE>{* the n best structures will be refined                    *} 
 DEFINE>{===>} waterrefine=200; 
 DEFINE>       structures_2=&waterrefine; 
 DEFINE> 
 DEFINE>{* number of steps for heating phase (100, 200, 300K)?      *} 
 DEFINE>{===>} waterheatsteps=100; 
 DEFINE> 
 DEFINE>{* number of steps for 300K sampling phase?                 *} 
 DEFINE>{===>} watersteps=1250; 
 DEFINE> 
 DEFINE>{* number of steps for cooling phase (300, 200, 100K)?      *} 
 DEFINE>{===>} watercoolsteps=500; 
 DEFINE> 
 DEFINE>{* write additional PDB files including solvent ?           *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} keepwater=false; 
 DEFINE> 
 DEFINE>{================================ Scoring =================================} 
 DEFINE>{* Settings for the scoring of the docking solutions *} 
 DEFINE> 
 DEFINE>{* Define the weights for the various terms for the sorting of structures (scoring) *} 
 DEFINE>{+ table: rows=14 "Evdw" "Eelec" "Eair" "Erg" "Esani" "Exrdc" "Expcs" "Edani" "Evean" "Ecdih" "Esym" "BSA" "dEint" "Edesolv" 
 DEFINE>          cols=3 "Rigid body EM" "semi-flexible SA" "Water refinement" +} 
 DEFINE>{===>} w_vdw_0=0.01; 
 DEFINE>{===>} w_vdw_1=1.0; 
 DEFINE>{===>} w_vdw_2=1.0; 
 DEFINE>{===>} w_elec_0=1.0; 
 DEFINE>{===>} w_elec_1=1.0; 
 DEFINE>{===>} w_elec_2=0.2; 
 DEFINE>{===>} w_dist_0=0.01; 
 DEFINE>{===>} w_dist_1=0.1; 
 DEFINE>{===>} w_dist_2=0.1; 
 DEFINE>{===>} w_rg_0=0.1; 
 DEFINE>{===>} w_rg_1=1.0; 
 DEFINE>{===>} w_rg_2=1.0; 
 DEFINE>{===>} w_sani_0=0.1; 
 DEFINE>{===>} w_sani_1=0.1; 
 DEFINE>{===>} w_sani_2=0.1; 
 DEFINE>{===>} w_xrdc_0=0.1; 
 DEFINE>{===>} w_xrdc_1=0.1; 
 DEFINE>{===>} w_xrdc_2=0.1; 
 DEFINE>{===>} w_xpcs_0=0.1; 
 DEFINE>{===>} w_xpcs_1=0.1; 
 DEFINE>{===>} w_xpcs_2=0.1; 
 DEFINE>{===>} w_dani_0=0.01; 
 DEFINE>{===>} w_dani_1=0.1; 
 DEFINE>{===>} w_dani_2=0.1; 
 DEFINE>{===>} w_vean_0=0.1; 
 DEFINE>{===>} w_vean_1=0.1; 
 DEFINE>{===>} w_vean_2=0.1; 
 DEFINE>{===>} w_cdih_0=0.0; 
 DEFINE>{===>} w_cdih_1=0.0; 
 DEFINE>{===>} w_cdih_2=0.0; 
 DEFINE>{===>} w_sym_0=0.1; 
 DEFINE>{===>} w_sym_1=0.1; 
 DEFINE>{===>} w_sym_2=0.1; 
 DEFINE>{===>} w_zres_0=0.1; 
 DEFINE>{===>} w_zres_1=0.1; 
 DEFINE>{===>} w_zres_2=0.1; 
 DEFINE>{===>} w_bsa_0=-0.01; 
 DEFINE>{===>} w_bsa_1=-0.01; 
 DEFINE>{===>} w_bsa_2=0.0; 
 DEFINE>{===>} w_deint_0=0.0; 
 DEFINE>{===>} w_deint_1=0.0; 
 DEFINE>{===>} w_deint_2=0.0; 
 DEFINE>{===>} w_desolv_0=1.0; 
 DEFINE>{===>} w_desolv_1=1.0; 
 DEFINE>{===>} w_desolv_2=1.0; 
 DEFINE> 
 DEFINE>{* It is possible to skip structures in the selection of structure in it0 *} 
 DEFINE>{* Give for this the number of structures to skip: *} 
 DEFINE>{===>} skip_struc=0; 
 DEFINE> 
 DEFINE>{======================= analysis and clustering ==========================} 
 DEFINE>{* Cutoff distance (proton-acceptor) to define an hydrogen bond? *} 
 DEFINE>{===>} dist_hb=2.5; 
 DEFINE> 
 DEFINE>{* Cutoff distance (carbon-carbon) to define an hydrophobic contact? *} 
 DEFINE>{===>} dist_nb=3.9; 
 DEFINE> 
 DEFINE>{* Clustering method (RMSD or Fraction of Common Contacts (FCC)) *} 
 DEFINE>{+ choice: "RMSD" "FCC" +} 
 DEFINE>{===>} clust_meth="RMSD"; 
 DEFINE> 
 DEFINE>{* RMSD cutoff for clustering? (Recommended values: RMSD 7.5, FCC 0.75) *} 
 DEFINE>{===>} clust_cutoff=5.00; 
 DEFINE> 
 DEFINE>{* Minimum cluster size? *} 
 DEFINE>{===>} clust_size=4; 
 DEFINE> 
 DEFINE>{* Chain-Agnostic Algorithm (used for FCC clustering in symmetrical complexes) *} 
 DEFINE>{+ choice: "true" "false" +} 
 DEFINE>{===>} fcc_ignc=false; 
 DEFINE> 
 DEFINE>{* Full or limited analysis of results? *} 
 DEFINE>{+ choice: "full" "cluster" "none" +} 
 DEFINE>{===>} runana=full; 
 DEFINE> 
 DEFINE> 
 DEFINE>{======================= final clean-up ===================================} 
 DEFINE>{* Clean up the run directory after completion (only files for struct #1 are kept) ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cleanup=true; 
 DEFINE> 
 DEFINE>{============================ parallel jobs ===============================} 
 DEFINE>{* How many nodes do you want to use in parallel? *} 
 DEFINE>{* leave unused fields blank, make sure that the queues are actually running *} 
 DEFINE>{+ table: rows=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" 
 DEFINE> cols=3 "queue command" "cns executable" "number of jobs" +} 
 DEFINE> 
 DEFINE>{===>} queue_1="/home/diracegi/grid/diracsubmit-haddock2.4"; 
 DEFINE>{===>} cns_exe_1="/home/enmr/software/cns/cns_solve_1.31-UU/intel-x86_64bit-linux/bin/cns"; 
 DEFINE>{===>} cpunumber_1=50000; 
 DEFINE> 
 DEFINE> 
 DEFINE>{===========================================================================} 
 DEFINE>{        things below this line do not normally need to be changed          } 
 DEFINE>{===========================================================================} 
 DEFINE> 
 DEFINE>) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve>!for global parameters (local variables (suffix ) => global variables): 
 CNSsolve>evaluate (&saprotocol.crossdock=&crossdock) 
 EVALUATE: symbol $_1_SAPROTOCOL.CROSSDOCK set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.randorien=&randorien) 
 EVALUATE: symbol $_1_SAPROTOCOL.RANDORIEN set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rebuildcplx=&rebuildcplx) 
 EVALUATE: symbol $_1_SAPROTOCOL.REBUILDCPLX set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidmini=&rigidmini) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDMINI set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidtrans=&rigidtrans) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDTRANS set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.expand=&expand) 
 EVALUATE: symbol $_1_SAPROTOCOL.EXPAND set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.expansion=&expansion) 
 EVALUATE: symbol $_1_SAPROTOCOL.EXPANSION set to   0.400000     (real)
 CNSsolve>evaluate (&saprotocol.randangle=&randangle) 
 EVALUATE: symbol $_1_SAPROTOCOL.RANDANGLE set to    6.00000     (real)
 CNSsolve> 
 CNSsolve>if (&saprotocol.expand eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.randorien=false) 
 CNSsolve>  evaluate (&saprotocol.rigidmini=false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&saprotocol.ntrials=&ntrials) 
 EVALUATE: symbol $_1_SAPROTOCOL.NTRIALS set to    5.00000     (real)
 CNSsolve>evaluate (&saprotocol.iniseed=&iniseed) 
 EVALUATE: symbol $_1_SAPROTOCOL.INISEED set to    917.000     (real)
 CNSsolve>evaluate (&saprotocol.tadhigh_t=&tadhigh_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADHIGH_T set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t1_init=&tadinit1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_INIT set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t2_init=&tadinit2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_INIT set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.t3_init=&tadinit3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_INIT set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.t1_final=&tadfinal1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_FINAL set to    500.000     (real)
 CNSsolve>evaluate (&saprotocol.t2_final=&tadfinal2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.t3_final=&tadfinal3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.inter_rigid=&inter_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_RIGID set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_rigid=&init_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_rigid=&fin_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool2=&init_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL2 set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool2=&fin_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool3=&init_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL3 set to   0.500000E-01 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool3=&fin_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.rotate180_it0=&rotate180_it0) 
 EVALUATE: symbol $_1_SAPROTOCOL.ROTATE180_IT0 set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rotate180_it1=&rotate180_it1) 
 EVALUATE: symbol $_1_SAPROTOCOL.ROTATE180_IT1 set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.tempstep=50) 
 EVALUATE: symbol $_1_SAPROTOCOL.TEMPSTEP set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.timestep=&timestep) 
 EVALUATE: symbol $_1_SAPROTOCOL.TIMESTEP set to   0.200000E-02 (real)
 CNSsolve>evaluate (&saprotocol.tadfactor=&tadfactor) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADFACTOR set to    8.00000     (real)
 CNSsolve>evaluate (&saprotocol.emstepstrans=&emstepstrans) 
 EVALUATE: symbol $_1_SAPROTOCOL.EMSTEPSTRANS set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.initiosteps=&initiosteps) 
 EVALUATE: symbol $_1_SAPROTOCOL.INITIOSTEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool1_steps=&cool1_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL1_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool2_steps=&cool2_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL2_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool3_steps=&cool3_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL3_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.fbeta=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.FBETA set to    100.000     (real)
 CNSsolve>evaluate (&saprotocol.mass=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.MASS set to    100.000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&filenames.fileroot=&fileroot) 
 EVALUATE: symbol $_1_FILENAMES.FILEROOT set to "complex" (string)
 CNSsolve>evaluate (&filenames.template=&fileroot + "_1.pdb") 
 EVALUATE: symbol $_1_FILENAMES.TEMPLATE set to "complex_1.pdb" (string)
 CNSsolve> 
 CNSsolve>evaluate (&iterations.ini_count    =1) 
 EVALUATE: symbol $_1_ITERATIONS.INI_COUNT set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.structures   =&structures_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.STRUCTURES set to    200.000     (real)
 CNSsolve>evaluate (&iterations.keepstruct   =&keepstruct_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.KEEPSTRUCT set to    200.000     (real)
 CNSsolve>evaluate (&iterations.w_vdw        =&w_vdw_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VDW set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_elec       =&w_elec_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_ELEC set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.w_dist       =&w_dist_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DIST set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_rg         =&w_rg_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_RG set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_sani       =&w_sani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SANI set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xrdc       =&w_xrdc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XRDC set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xpcs       =&w_xpcs_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XPCS set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_dani       =&w_dani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DANI set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_vean       =&w_vean_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VEAN set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_cdih       =&w_cdih_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_CDIH set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_sym        =&w_sym_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SYM set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_zres       =&w_zres_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_ZRES set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_bsa        =&w_bsa_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_BSA set to  -0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_deint      =&w_deint_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DEINT set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_desolv     =&w_desolv_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DESOLV set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.anastruc     =&anastruc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.ANASTRUC set to    200.000     (real)
 CNSsolve>evaluate (&iterations.w_lcc        = &w_lcc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_LCC set to   -400.000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate (&data.ncomponents=&ncomponents) 
 EVALUATE: symbol $_1_DATA.NCOMPONENTS set to    2.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($nmol=1) 
 EVALUATE: symbol $NMOL set to    1.00000     (real)
 CNSsolve>while ($nmol <= &data.ncomponents) loop mol 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>  !aa topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_top_$nmol=&prot_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_1 set to "protein-allhdg5-4.top" (string)
 CNSsolve>  evaluate (&toppar.prot_link_$nmol=&prot_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_1 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>  evaluate (&toppar.prot_par_$nmol=&prot_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_1 set to "protein-allhdg5-4.param" (string)
 CNSsolve> 
 CNSsolve>  !coarse grained topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_cg_top_$nmol=&prot_cg_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_TOP_1 set to "protein-CG-Martini-2-2.top" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_link_$nmol=&prot_cg_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_LINK_1 set to "protein-CG-Martini-2-2.link" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_par_$nmol=&prot_cg_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_PAR_1 set to "protein-CG-Martini-2-2.param" (string)
 CNSsolve> 
 CNSsolve>  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid) 
 CNSsolve>  evaluate (&toppar.prot_coor_$nmol=&prot_coor_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_1 set to "protein1.pdb" (string)
 CNSsolve>  evaluate (&toppar.prot_root_$nmol=&prot_root_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_1 set to "protein1" (string)
 CNSsolve>  evaluate (&toppar.fix_origin_$nmol=&fix_origin_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.FIX_ORIGIN_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.dna_$nmol=&dna_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.DNA_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cyclicpept_$nmol=&cyclicpept_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CYCLICPEPT_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.shape_$nmol=&shape_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.SHAPE_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cg_$nmol=&cg_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CG_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.prot_segid_$nmol=&prot_segid_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_1 set to "A" (string)
 CNSsolve> 
 CNSsolve>  !semi flexible segments 
 CNSsolve>  evaluate (&toppar.nseg_$nmol=&nseg_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_1 set to   -1.00000     (real)
 CNSsolve>  evaluate ($nseg = 1) 
 EVALUATE: symbol $NSEG set to    1.00000     (real)
 CNSsolve>  while ($nseg <= &toppar.nseg_$nmol) loop seg 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_seg_$nmol_$nseg=&start_seg_$nmol_$nseg) 
 CNSsolve>    evaluate (&toppar.end_seg_$nmol_$nseg=&end_seg_$nmol_$nseg) 
 CNSsolve>    evaluate ($nseg = $nseg + 1) 
 CNSsolve>  end loop seg 
 CNSsolve> 
 CNSsolve>  !fully flexible segments 
 CNSsolve>  evaluate (&toppar.nfle_$nmol=&nfle_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_1 set to    0.00000     (real)
 CNSsolve>  evaluate ($nfle = 1) 
 EVALUATE: symbol $NFLE set to    1.00000     (real)
 CNSsolve>  while ($nfle <= &toppar.nfle_$nmol) loop fle 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_fle_$nmol_$nfle=&start_fle_$nmol_$nfle) 
 CNSsolve>    evaluate (&toppar.end_fle_$nmol_$nfle=&end_fle_$nmol_$nfle) 
 CNSsolve>    evaluate ($nfle = $nfle + 1) 
 CNSsolve>  end loop fle 
 CNSsolve> 
 CNSsolve>  !histidine patches 
 CNSsolve>  evaluate (&toppar.autohis=&autohis) 
 EVALUATE: symbol $_1_TOPPAR.AUTOHIS set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.nhisd_$nmol=&numhisd_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISD_1 set to    4.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_1 set to    474.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_2 set to    514.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_3 set to    615.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_4 set to    697.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    5.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate (&toppar.nhise_$nmol=&numhise_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISE_1 set to    6.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_1 set to    449.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_2 set to    483.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_3 set to    498.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_4 set to    604.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    5.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_5 set to    654.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    6.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_6 set to    695.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    7.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate ($nmol = $nmol + 1) 
 EVALUATE: symbol $NMOL set to    2.00000     (real)
 CNSsolve> 
 CNSsolve>end loop mol 
 CNSsolve>while ($nmol <= &data.ncomponents) loop mol 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>  !aa topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_top_$nmol=&prot_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_2 set to "protein-allhdg5-4.top" (string)
 CNSsolve>  evaluate (&toppar.prot_link_$nmol=&prot_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_2 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>  evaluate (&toppar.prot_par_$nmol=&prot_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_2 set to "protein-allhdg5-4.param" (string)
 CNSsolve> 
 CNSsolve>  !coarse grained topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_cg_top_$nmol=&prot_cg_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_TOP_2 set to "protein-CG-Martini-2-2.top" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_link_$nmol=&prot_cg_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_LINK_2 set to "protein-CG-Martini-2-2.link" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_par_$nmol=&prot_cg_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_PAR_2 set to "protein-CG-Martini-2-2.param" (string)
 CNSsolve> 
 CNSsolve>  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid) 
 CNSsolve>  evaluate (&toppar.prot_coor_$nmol=&prot_coor_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_2 set to "protein2.pdb" (string)
 CNSsolve>  evaluate (&toppar.prot_root_$nmol=&prot_root_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_2 set to "protein2" (string)
 CNSsolve>  evaluate (&toppar.fix_origin_$nmol=&fix_origin_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.FIX_ORIGIN_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.dna_$nmol=&dna_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.DNA_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cyclicpept_$nmol=&cyclicpept_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CYCLICPEPT_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.shape_$nmol=&shape_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.SHAPE_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cg_$nmol=&cg_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CG_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.prot_segid_$nmol=&prot_segid_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_2 set to "B" (string)
 CNSsolve> 
 CNSsolve>  !semi flexible segments 
 CNSsolve>  evaluate (&toppar.nseg_$nmol=&nseg_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_2 set to   -1.00000     (real)
 CNSsolve>  evaluate ($nseg = 1) 
 EVALUATE: symbol $NSEG set to    1.00000     (real)
 CNSsolve>  while ($nseg <= &toppar.nseg_$nmol) loop seg 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_seg_$nmol_$nseg=&start_seg_$nmol_$nseg) 
 CNSsolve>    evaluate (&toppar.end_seg_$nmol_$nseg=&end_seg_$nmol_$nseg) 
 CNSsolve>    evaluate ($nseg = $nseg + 1) 
 CNSsolve>  end loop seg 
 CNSsolve> 
 CNSsolve>  !fully flexible segments 
 CNSsolve>  evaluate (&toppar.nfle_$nmol=&nfle_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($nfle = 1) 
 EVALUATE: symbol $NFLE set to    1.00000     (real)
 CNSsolve>  while ($nfle <= &toppar.nfle_$nmol) loop fle 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_fle_$nmol_$nfle=&start_fle_$nmol_$nfle) 
 CNSsolve>    evaluate (&toppar.end_fle_$nmol_$nfle=&end_fle_$nmol_$nfle) 
 CNSsolve>    evaluate ($nfle = $nfle + 1) 
 CNSsolve>  end loop fle 
 CNSsolve> 
 CNSsolve>  !histidine patches 
 CNSsolve>  evaluate (&toppar.autohis=&autohis) 
 EVALUATE: symbol $_1_TOPPAR.AUTOHIS set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.nhisd_$nmol=&numhisd_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISD_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate (&toppar.nhise_$nmol=&numhise_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISE_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate ($nmol = $nmol + 1) 
 EVALUATE: symbol $NMOL set to    3.00000     (real)
 CNSsolve> 
 CNSsolve>end loop mol 
 CNSsolve>while ($nmol <= &data.ncomponents) loop mol 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>  !aa topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_top_$nmol=&prot_top_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_link_$nmol=&prot_link_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_par_$nmol=&prot_par_mol$nmol ) 
 CNSsolve> 
 CNSsolve>  !coarse grained topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_cg_top_$nmol=&prot_cg_top_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_cg_link_$nmol=&prot_cg_link_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_cg_par_$nmol=&prot_cg_par_mol$nmol ) 
 CNSsolve> 
 CNSsolve>  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid) 
 CNSsolve>  evaluate (&toppar.prot_coor_$nmol=&prot_coor_mol$nmol) 
 CNSsolve>  evaluate (&toppar.prot_root_$nmol=&prot_root_mol$nmol) 
 CNSsolve>  evaluate (&toppar.fix_origin_$nmol=&fix_origin_mol$nmol) 
 CNSsolve>  evaluate (&toppar.dna_$nmol=&dna_mol$nmol) 
 CNSsolve>  evaluate (&toppar.cyclicpept_$nmol=&cyclicpept_mol$nmol) 
 CNSsolve>  evaluate (&toppar.shape_$nmol=&shape_mol$nmol) 
 CNSsolve>  evaluate (&toppar.cg_$nmol=&cg_mol$nmol) 
 CNSsolve>  evaluate (&toppar.prot_segid_$nmol=&prot_segid_mol$nmol) 
 CNSsolve> 
 CNSsolve>  !semi flexible segments 
 CNSsolve>  evaluate (&toppar.nseg_$nmol=&nseg_$nmol) 
 CNSsolve>  evaluate ($nseg = 1) 
 CNSsolve>  while ($nseg <= &toppar.nseg_$nmol) loop seg 
 CNSsolve>    evaluate (&toppar.start_seg_$nmol_$nseg=&start_seg_$nmol_$nseg) 
 CNSsolve>    evaluate (&toppar.end_seg_$nmol_$nseg=&end_seg_$nmol_$nseg) 
 CNSsolve>    evaluate ($nseg = $nseg + 1) 
 CNSsolve>  end loop seg 
 CNSsolve> 
 CNSsolve>  !fully flexible segments 
 CNSsolve>  evaluate (&toppar.nfle_$nmol=&nfle_$nmol) 
 CNSsolve>  evaluate ($nfle = 1) 
 CNSsolve>  while ($nfle <= &toppar.nfle_$nmol) loop fle 
 CNSsolve>    evaluate (&toppar.start_fle_$nmol_$nfle=&start_fle_$nmol_$nfle) 
 CNSsolve>    evaluate (&toppar.end_fle_$nmol_$nfle=&end_fle_$nmol_$nfle) 
 CNSsolve>    evaluate ($nfle = $nfle + 1) 
 CNSsolve>  end loop fle 
 CNSsolve> 
 CNSsolve>  !histidine patches 
 CNSsolve>  evaluate (&toppar.autohis=&autohis) 
 CNSsolve>  evaluate (&toppar.nhisd_$nmol=&numhisd_$nmol) 
 CNSsolve>  evaluate ($ncc=1) 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate (&toppar.nhise_$nmol=&numhise_$nmol) 
 CNSsolve>  evaluate ($ncc=1) 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate ($nmol = $nmol + 1) 
 CNSsolve> 
 CNSsolve>end loop mol 
 CNSsolve> 
 CNSsolve>! non-bonded parameter set to use 
 CNSsolve>evaluate (&toppar.par_nonbonded=&par_nonbonded) 
 EVALUATE: symbol $_1_TOPPAR.PAR_NONBONDED set to "OPLSX" (string)
 CNSsolve> 
 CNSsolve>! z-restraining 
 CNSsolve>evaluate (&Data.flags.zres =  &zres_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.ZRES set to FALSE (logical)
 CNSsolve>evaluate (&data.numzres=&numzres) 
 EVALUATE: symbol $_1_DATA.NUMZRES set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numzres) loop zres 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.zres_sta_$ncc=&zres_sta_$ncc) 
 CNSsolve>  evaluate (&toppar.zres_end_$ncc=&zres_end_$ncc) 
 CNSsolve>  evaluate (&toppar.zres_seg_$ncc=&zres_seg_$ncc) 
 CNSsolve>  evaluate (&toppar.zres_type_$ncc=&zres_type_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop zres 
 CNSsolve> 
 CNSsolve>! NCS restraints 
 CNSsolve>evaluate (&data.kncs=&kncs) 
 Assuming literal string "&KNCS"
 EVALUATE: symbol $_1_DATA.KNCS set to "&KNCS" (string)
 CNSsolve>evaluate (&Data.flags.ncs  =  &ncs_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.NCS set to FALSE (logical)
 CNSsolve>evaluate (&data.numncs=&numncs) 
 EVALUATE: symbol $_1_DATA.NUMNCS set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numncs) loop ncs 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.ncs_sta1_$ncc=&ncs_sta1_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_end1_$ncc=&ncs_end1_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_seg1_$ncc=&ncs_seg1_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_sta2_$ncc=&ncs_sta2_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_end2_$ncc=&ncs_end2_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_seg2_$ncc=&ncs_seg2_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop ncs 
 CNSsolve> 
 CNSsolve>! Symmetry restraints 
 CNSsolve>evaluate (&data.ksym=&ksym) 
 EVALUATE: symbol $_1_DATA.KSYM set to    10.0000     (real)
 CNSsolve>evaluate (&Data.flags.sym  =  &sym_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.SYM set to FALSE (logical)
 CNSsolve>evaluate (&data.numc2sym=&numc2sym) 
 EVALUATE: symbol $_1_DATA.NUMC2SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc2sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c2sym_sta1_$nsym=&c2sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_end1_$nsym=&c2sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_seg1_$nsym=&c2sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_sta2_$nsym=&c2sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_end2_$nsym=&c2sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_seg2_$nsym=&c2sym_seg2_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc3sym=&numc3sym) 
 EVALUATE: symbol $_1_DATA.NUMC3SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc3sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c3sym_sta1_$nsym=&c3sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_end1_$nsym=&c3sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_seg1_$nsym=&c3sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_sta2_$nsym=&c3sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_end2_$nsym=&c3sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_seg2_$nsym=&c3sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_sta3_$nsym=&c3sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_end3_$nsym=&c3sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_seg3_$nsym=&c3sym_seg3_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.nums3sym=&nums3sym) 
 EVALUATE: symbol $_1_DATA.NUMS3SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &nums3sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.s3sym_sta1_$nsym=&s3sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_end1_$nsym=&s3sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_seg1_$nsym=&s3sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_sta2_$nsym=&s3sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_end2_$nsym=&s3sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_seg2_$nsym=&s3sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_sta3_$nsym=&s3sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_end3_$nsym=&s3sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_seg3_$nsym=&s3sym_seg3_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc4sym=&numc4sym) 
 EVALUATE: symbol $_1_DATA.NUMC4SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc4sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c4sym_sta1_$nsym=&c4sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end1_$nsym=&c4sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg1_$nsym=&c4sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_sta2_$nsym=&c4sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end2_$nsym=&c4sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg2_$nsym=&c4sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_sta3_$nsym=&c4sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end3_$nsym=&c4sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg3_$nsym=&c4sym_seg3_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_sta4_$nsym=&c4sym_sta4_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end4_$nsym=&c4sym_end4_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg4_$nsym=&c4sym_seg4_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc5sym=&numc5sym) 
 EVALUATE: symbol $_1_DATA.NUMC5SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc5sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c5sym_sta1_$nsym=&c5sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end1_$nsym=&c5sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg1_$nsym=&c5sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta2_$nsym=&c5sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end2_$nsym=&c5sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg2_$nsym=&c5sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta3_$nsym=&c5sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end3_$nsym=&c5sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg3_$nsym=&c5sym_seg3_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta4_$nsym=&c5sym_sta4_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end4_$nsym=&c5sym_end4_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg4_$nsym=&c5sym_seg4_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta5_$nsym=&c5sym_sta5_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end5_$nsym=&c5sym_end5_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg5_$nsym=&c5sym_seg5_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc6sym=&numc6sym) 
 EVALUATE: symbol $_1_DATA.NUMC6SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc6sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c6sym_sta1_$nsym=&c6sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end1_$nsym=&c6sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg1_$nsym=&c6sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta2_$nsym=&c6sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end2_$nsym=&c6sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg2_$nsym=&c6sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta3_$nsym=&c6sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end3_$nsym=&c6sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg3_$nsym=&c6sym_seg3_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta4_$nsym=&c6sym_sta4_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end4_$nsym=&c6sym_end4_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg4_$nsym=&c6sym_seg4_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta5_$nsym=&c6sym_sta5_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end5_$nsym=&c6sym_end5_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg5_$nsym=&c6sym_seg5_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta6_$nsym=&c6sym_sta6_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end6_$nsym=&c6sym_end6_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg6_$nsym=&c6sym_seg6_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>if ( &data.numc2sym eq 6) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc3sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc4sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc5sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc6sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!Dihedrals, DNA and distance restraints 
 CNSsolve>evaluate (&Data.dnarest = &dnarest_on) 
 EVALUATE: symbol $_1_DATA.DNAREST set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.cdih =  &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.CDIH set to FALSE (logical)
 CNSsolve>evaluate (&Data.cdih.on = &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.CDIH.ON set to FALSE (logical)
 CNSsolve>evaluate (&Data.ssdihed = &ssdihed) 
 Assuming literal string "ALPHABETA"
 EVALUATE: symbol $_1_DATA.SSDIHED set to "ALPHABETA" (string)
 CNSsolve>evaluate (&Data.error_dih = &error_dih) 
 EVALUATE: symbol $_1_DATA.ERROR_DIH set to    10.0000     (real)
 CNSsolve>evaluate (&data.dihedrals.on=&dihedrals_on) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS.ON set to FALSE (logical)
 CNSsolve>evaluate (&data.dihedrals_hot=&dihedrals_hot) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_HOT set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool1=&dihedrals_cool1) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool2=&dihedrals_cool2) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool3=&dihedrals_cool3) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL3 set to    200.000     (real)
 CNSsolve>evaluate (&data.hbonds_on=&hbonds_on) 
 EVALUATE: symbol $_1_DATA.HBONDS_ON set to FALSE (logical)
 CNSsolve> 
 CNSsolve>! RDC restraints 
 CNSsolve>evaluate (&Data.flags.vean =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.VEAN set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.xrdc =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XRDC set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.sani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.SANI set to FALSE (logical)
 CNSsolve>evaluate (&data.numrdc=&numrdc) 
 EVALUATE: symbol $_1_DATA.NUMRDC set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &data.numrdc) loop rdc 
 NEXTCD: condition evaluated as false
 CNSsolve>  if (&rdc_choice_$ncc = "VANGLE") then 
 CNSsolve>    evaluate (&Data.flags.vean =  true) 
 CNSsolve>  end if 
 CNSsolve>  if (&rdc_choice_$ncc = "SANI") then 
 CNSsolve>    evaluate (&Data.flags.sani =  true) 
 CNSsolve>  end if 
 CNSsolve>  if (&rdc_choice_$ncc = "XRDC") then 
 CNSsolve>    evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate (&data.rdc_choice_$ncc=&rdc_choice_$ncc) 
 CNSsolve>  evaluate (&data.rdc_firstIt_$ncc=&rdc_firstIt_$ncc) 
 CNSsolve>  evaluate (&data.rdc_lastIt_$ncc=&rdc_lastIt_$ncc) 
 CNSsolve>  evaluate (&data.rdc_hot_$ncc=&rdc_hot_$ncc) 
 CNSsolve>  evaluate (&data.rdc_cool1_$ncc=&rdc_cool1_$ncc) 
 CNSsolve>  evaluate (&data.rdc_cool2_$ncc=&rdc_cool2_$ncc) 
 CNSsolve>  evaluate (&data.rdc_cool3_$ncc=&rdc_cool3_$ncc) 
 CNSsolve>  evaluate (&data.rdc_r_$ncc=&rdc_r_$ncc) 
 CNSsolve>  evaluate (&data.rdc_d_$ncc=&rdc_d_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_hot_$ncc=&ini_bor_hot_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_cool1_$ncc=&ini_bor_cool1_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_cool2_$ncc=&ini_bor_cool2_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_cool3_$ncc=&ini_bor_cool3_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_hot_$ncc=&ini_cen_hot_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_cool1_$ncc=&ini_cen_cool1_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_cool2_$ncc=&ini_cen_cool2_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_cool3_$ncc=&ini_cen_cool3_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_hot_$ncc=&fin_bor_hot_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_cool1_$ncc=&fin_bor_cool1_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_cool2_$ncc=&fin_bor_cool2_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_cool3_$ncc=&fin_bor_cool3_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_hot_$ncc=&fin_cen_hot_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_cool1_$ncc=&fin_cen_cool1_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_cool2_$ncc=&fin_cen_cool2_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_cool3_$ncc=&fin_cen_cool3_$ncc) 
 CNSsolve>  evaluate ($ncc=$ncc+1) 
 CNSsolve>end loop rdc 
 CNSsolve> 
 CNSsolve>! PCS restraints 
 CNSsolve>evaluate (&Data.flags.xpcs =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XPCS set to FALSE (logical)
 CNSsolve>evaluate (&data.numpcs=&numpcs) 
 EVALUATE: symbol $_1_DATA.NUMPCS set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numpcs) loop pcs 
 NEXTCD: condition evaluated as false
 CNSsolve>  if (&pcs_choice_$ncc = "XPCS") then 
 CNSsolve>    evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate (&data.pcs_choice_$ncc=&pcs_choice_$ncc) 
 CNSsolve>  evaluate (&data.pcs_firstIt_$ncc=&pcs_firstIt_$ncc) 
 CNSsolve>  evaluate (&data.pcs_lastIt_$ncc=&pcs_lastIt_$ncc) 
 CNSsolve>  evaluate (&data.pcs_hot_$ncc=&pcs_hot_$ncc) 
 CNSsolve>  evaluate (&data.pcs_cool1_$ncc=&pcs_cool1_$ncc) 
 CNSsolve>  evaluate (&data.pcs_cool2_$ncc=&pcs_cool2_$ncc) 
 CNSsolve>  evaluate (&data.pcs_cool3_$ncc=&pcs_cool3_$ncc) 
 CNSsolve>  evaluate (&data.pcs_r_$ncc=&pcs_r_$ncc) 
 CNSsolve>  evaluate (&data.pcs_d_$ncc=&pcs_d_$ncc) 
 CNSsolve>  evaluate ($ncc=$ncc+1) 
 CNSsolve>end loop pcs 
 CNSsolve> 
 CNSsolve>! DANI restraints 
 CNSsolve>evaluate (&Data.flags.dani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.DANI set to FALSE (logical)
 CNSsolve>evaluate (&data.numdani=&numdani) 
 EVALUATE: symbol $_1_DATA.NUMDANI set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numdani) loop dani 
 NEXTCD: condition evaluated as false
 CNSsolve>  if (&dan_choice_$ncc = "DANI") then 
 CNSsolve>    evaluate (&Data.flags.dani =  true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate (&data.dan_choice_$ncc=&dan_choice_$ncc) 
 CNSsolve>  evaluate (&data.dan_firstIt_$ncc=&dan_firstIt_$ncc) 
 CNSsolve>  evaluate (&data.dan_lastIt_$ncc=&dan_lastIt_$ncc) 
 CNSsolve>  evaluate (&data.dan_hot_$ncc=&dan_hot_$ncc) 
 CNSsolve>  evaluate (&data.dan_cool1_$ncc=&dan_cool1_$ncc) 
 CNSsolve>  evaluate (&data.dan_cool2_$ncc=&dan_cool2_$ncc) 
 CNSsolve>  evaluate (&data.dan_cool3_$ncc=&dan_cool3_$ncc) 
 CNSsolve>  evaluate (&data.dan_tc_$ncc=&dan_tc_$ncc) 
 CNSsolve>  evaluate (&data.dan_anis_$ncc=&dan_anis_$ncc) 
 CNSsolve>  evaluate (&data.dan_r_$ncc=&dan_r_$ncc) 
 CNSsolve>  evaluate (&data.dan_wh_$ncc=&dan_wh_$ncc) 
 CNSsolve>  evaluate (&data.dan_wn_$ncc=&dan_wn_$ncc) 
 CNSsolve>  evaluate ($ncc=$ncc+1) 
 CNSsolve>end loop dani 
 CNSsolve> 
 CNSsolve>! planarity restraints 
 CNSsolve>evaluate (&Data.flags.plan =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.PLAN set to FALSE (logical)
 CNSsolve> 
 CNSsolve>! distance restraints 
 CNSsolve>evaluate (&Data.flags.noe  =  true) 
 EVALUATE: symbol $_1_DATA.FLAGS.NOE set to TRUE (logical)
 CNSsolve>evaluate (&data.scaling=&air_scaling) 
 EVALUATE: symbol $_1_DATA.SCALING set to FALSE (logical)
 CNSsolve>evaluate (&data.totnoe_unamb=&tot_unamb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_UNAMB set to    25.0000     (real)
 CNSsolve>evaluate (&data.unamb_firstit=&unamb_firstit) 
 EVALUATE: symbol $_1_DATA.UNAMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.unamb_lastit=&unamb_lastit) 
 EVALUATE: symbol $_1_DATA.UNAMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.unamb_hot=&unamb_hot) 
 EVALUATE: symbol $_1_DATA.UNAMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool1=&unamb_cool1) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool2=&unamb_cool2) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool3=&unamb_cool3) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.noecv=&noecv) 
 EVALUATE: symbol $_1_DATA.NOECV set to TRUE (logical)
 CNSsolve>evaluate (&data.ncvpart=&ncvpart) 
 EVALUATE: symbol $_1_DATA.NCVPART set to    2.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.totnoe_amb=&tot_amb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_AMB set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_firstit=&amb_firstit) 
 EVALUATE: symbol $_1_DATA.AMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_lastit=&amb_lastit) 
 EVALUATE: symbol $_1_DATA.AMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.amb_hot=&amb_hot) 
 EVALUATE: symbol $_1_DATA.AMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool1=&amb_cool1) 
 EVALUATE: symbol $_1_DATA.AMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool2=&amb_cool2) 
 EVALUATE: symbol $_1_DATA.AMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.amb_cool3=&amb_cool3) 
 EVALUATE: symbol $_1_DATA.AMB_COOL3 set to    50.0000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.hbond_firstit=&hbond_firstit) 
 EVALUATE: symbol $_1_DATA.HBOND_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.hbond_lastit=&hbond_lastit) 
 EVALUATE: symbol $_1_DATA.HBOND_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.hbond_hot=&hbond_hot) 
 EVALUATE: symbol $_1_DATA.HBOND_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool1=&hbond_cool1) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool2=&hbond_cool2) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool3=&hbond_cool3) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL3 set to    50.0000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.mrswi_hot=&mrswi_hot) 
 EVALUATE: symbol $_1_DATA.MRSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool1=&mrswi_cool1) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool2=&mrswi_cool2) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool3=&mrswi_cool3) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL3 set to   0.500000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.rswi_hot=&rswi_hot) 
 EVALUATE: symbol $_1_DATA.RSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool1=&rswi_cool1) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool2=&rswi_cool2) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool3=&rswi_cool3) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL3 set to   0.500000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.masy_hot=&masy_hot) 
 EVALUATE: symbol $_1_DATA.MASY_HOT set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool1=&masy_cool1) 
 EVALUATE: symbol $_1_DATA.MASY_COOL1 set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool2=&masy_cool2) 
 EVALUATE: symbol $_1_DATA.MASY_COOL2 set to  -0.100000     (real)
 CNSsolve>evaluate (&data.masy_cool3=&masy_cool3) 
 EVALUATE: symbol $_1_DATA.MASY_COOL3 set to  -0.100000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.asy_hot=&asy_hot) 
 EVALUATE: symbol $_1_DATA.ASY_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool1=&asy_cool1) 
 EVALUATE: symbol $_1_DATA.ASY_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool2=&asy_cool2) 
 EVALUATE: symbol $_1_DATA.ASY_COOL2 set to   0.100000     (real)
 CNSsolve>evaluate (&data.asy_cool3=&asy_cool3) 
 EVALUATE: symbol $_1_DATA.ASY_COOL3 set to   0.100000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.ranair=&ranair) 
 EVALUATE: symbol $_1_DATA.RANAIR set to FALSE (logical)
 CNSsolve>if (&data.ranair eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&data.noecv = false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&data.cmrest=&cmrest) 
 EVALUATE: symbol $_1_DATA.CMREST set to TRUE (logical)
 CNSsolve>evaluate (&data.cmtight=&cmtight) 
 EVALUATE: symbol $_1_DATA.CMTIGHT set to TRUE (logical)
 CNSsolve>evaluate (&data.kcont=&kcont) 
 EVALUATE: symbol $_1_DATA.KCONT set to    1.00000     (real)
 CNSsolve>evaluate (&data.surfrest=&surfrest) 
 EVALUATE: symbol $_1_DATA.SURFREST set to TRUE (logical)
 CNSsolve>evaluate (&data.ksurf=&ksurf) 
 EVALUATE: symbol $_1_DATA.KSURF set to    1.00000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! radius of gydration restraints 
 CNSsolve>evaluate (&data.flags.rg=&rgrest) 
 EVALUATE: symbol $_1_DATA.FLAGS.RG set to FALSE (logical)
 CNSsolve>evaluate (&data.rgtarg=&rgtarg) 
 Assuming literal string "&RGTARG"
 EVALUATE: symbol $_1_DATA.RGTARG set to "&RGTARG" (string)
 CNSsolve>evaluate (&data.krg_hot=&krg_hot) 
 Assuming literal string "&KRG_HOT"
 EVALUATE: symbol $_1_DATA.KRG_HOT set to "&KRG_HOT" (string)
 CNSsolve>evaluate (&data.krg_cool1=&krg_cool1) 
 Assuming literal string "&KRG_COOL1"
 EVALUATE: symbol $_1_DATA.KRG_COOL1 set to "&KRG_COOL1" (string)
 CNSsolve>evaluate (&data.krg_cool2=&krg_cool2) 
 Assuming literal string "&KRG_COOL2"
 EVALUATE: symbol $_1_DATA.KRG_COOL2 set to "&KRG_COOL2" (string)
 CNSsolve>evaluate (&data.krg_cool3=&krg_cool3) 
 Assuming literal string "&KRG_COOL3"
 EVALUATE: symbol $_1_DATA.KRG_COOL3 set to "&KRG_COOL3" (string)
 CNSsolve>evaluate (&data.rgsele=&rgsele) 
 Assuming literal string "&RGSELE"
 EVALUATE: symbol $_1_DATA.RGSELE set to "&RGSELE" (string)
 CNSsolve> 
 CNSsolve>evaluate (&data.kzres=&kzres) 
 Assuming literal string "&KZRES"
 EVALUATE: symbol $_1_DATA.KZRES set to "&KZRES" (string)
 CNSsolve>evaluate (&data.zresmax=&zresmax) 
 Assuming literal string "&ZRESMAX"
 EVALUATE: symbol $_1_DATA.ZRESMAX set to "&ZRESMAX" (string)
 CNSsolve>evaluate (&data.zresmin=&zresmin) 
 Assuming literal string "&ZRESMIN"
 EVALUATE: symbol $_1_DATA.ZRESMIN set to "&ZRESMIN" (string)
 CNSsolve> 
 CNSsolve>! keep or delete non-polar hydrogens 
 CNSsolve>evaluate (&toppar.delenph=&delenph) 
 EVALUATE: symbol $_1_TOPPAR.DELENPH set to TRUE (logical)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!Electrostatics: 
 CNSsolve>evaluate (&Data.flags.dihed = &dihedflag) 
 EVALUATE: symbol $_1_DATA.FLAGS.DIHED set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec0 = &elecflag_0) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC0 set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec1 = &elecflag_1) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC1 set to TRUE (logical)
 CNSsolve>evaluate (&Data.epsilon0 = &epsilon_0) 
 EVALUATE: symbol $_1_DATA.EPSILON0 set to    10.0000     (real)
 CNSsolve>evaluate (&Data.epsilon1 = &epsilon_1) 
 EVALUATE: symbol $_1_DATA.EPSILON1 set to    1.00000     (real)
 CNSsolve>evaluate (&Data.dielec0  = &dielec_0) 
 Assuming literal string "RDIE"
 EVALUATE: symbol $_1_DATA.DIELEC0 set to "RDIE" (string)
 CNSsolve>evaluate (&Data.dielec1  = &dielec_1) 
 Assuming literal string "RDIE"
 EVALUATE: symbol $_1_DATA.DIELEC1 set to "RDIE" (string)
 CNSsolve> 
 CNSsolve>!Check for CG and if present force cdie 
 CNSsolve>evaluate($cg = false) 
 EVALUATE: symbol $CG set to FALSE (logical)
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cgmol 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  if ($Toppar.cg_$nchain1 eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate($cg = true) 
 CNSsolve>  end if 
 CNSsolve>end loop cgmol 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cgmol 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  if ($Toppar.cg_$nchain1 eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate($cg = true) 
 CNSsolve>  end if 
 CNSsolve>end loop cgmol 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cgmol 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.cg_$nchain1 eq true) then 
 CNSsolve>    evaluate($cg = true) 
 CNSsolve>  end if 
 CNSsolve>end loop cgmol 
 CNSsolve> 
 CNSsolve>if ($cg = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.dielec0  = cdie) 
 CNSsolve>  evaluate (&Data.dielec1  = cdie) 
 CNSsolve>  evaluate (&Data.epsilon1 = &Data.epsilon0) 
 CNSsolve>  display "FORCING CDIE FOR ELECTROSTATICS BECAUSE OF COARSE GRAINING" 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!Interaction matrix: 
 CNSsolve>evaluate ($nmol1=1) 
 EVALUATE: symbol $NMOL1 set to    1.00000     (real)
 CNSsolve>while ($nmol1 <= &data.ncomponents) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    2.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_1 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_2 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    2.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= &data.ncomponents) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_2 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    3.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= &data.ncomponents) loop mol1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 CNSsolve>end loop mol1 
 CNSsolve> 
 CNSsolve>!intermolecular contacts analysis 
 CNSsolve>evaluate (&data.hb_dist=&dist_hb) 
 EVALUATE: symbol $_1_DATA.HB_DIST set to    2.50000     (real)
 CNSsolve>evaluate (&data.nb_dist=&dist_nb) 
 EVALUATE: symbol $_1_DATA.NB_DIST set to    3.90000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!water refinement 
 CNSsolve>evaluate (&refine.firstwater=&firstwater) 
 EVALUATE: symbol $_1_REFINE.FIRSTWATER set to "yes" (string)
 CNSsolve>evaluate (&refine.solvshell=&solvshell) 
 EVALUATE: symbol $_1_REFINE.SOLVSHELL set to TRUE (logical)
 CNSsolve>evaluate (&refine.keepwater=&keepwater) 
 EVALUATE: symbol $_1_REFINE.KEEPWATER set to FALSE (logical)
 CNSsolve>evaluate (&refine.waterrefine=min(&structures_1,&waterrefine)) 
 EVALUATE: symbol $_1_REFINE.WATERREFINE set to    200.000     (real)
 CNSsolve>evaluate (&refine.solvent=&solvent) 
 EVALUATE: symbol $_1_REFINE.SOLVENT set to "water" (string)
 CNSsolve>evaluate (&refine.heatsteps=&waterheatsteps) 
 EVALUATE: symbol $_1_REFINE.HEATSTEPS set to    100.000     (real)
 CNSsolve>evaluate (&refine.steps=&watersteps) 
 EVALUATE: symbol $_1_REFINE.STEPS set to    1250.00     (real)
 CNSsolve>evaluate (&refine.coolsteps=&watercoolsteps) 
 EVALUATE: symbol $_1_REFINE.COOLSTEPS set to    500.000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the non-bonded parameters (the section was taken out of 
 CNSsolve>!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!): 
 CNSsolve>if (&toppar.par_nonbonded eq "PROLSQ") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 1.0) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 20) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 4) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 1) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "PARMALLH6") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 0.8) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "OPLSX") then 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.repel_radius = 0.0) 
 EVALUATE: symbol $_1_TOPPAR.REPEL_RADIUS set to    0.00000     (real)
 CNSsolve>else        {...now the standard PARALLHDG parameters} 
 CNSsolve>    evaluate (&toppar.repel_radius = 0.78) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Water in rigid body docking 
 CNSsolve>evaluate (&data.waterdock=&waterdock) 
 EVALUATE: symbol $_1_DATA.WATERDOCK set to FALSE (logical)
 CNSsolve>evaluate (&data.db_method=&db_method) 
 EVALUATE: symbol $_1_DATA.DB_METHOD set to "kytedoolittle" (string)
 CNSsolve>evaluate (&data.water_tokeep=&water_tokeep) 
 EVALUATE: symbol $_1_DATA.WATER_TOKEEP set to   0.500000     (real)
 CNSsolve>evaluate (&data.dnap_water_tokeep=&dnap_water_tokeep) 
 EVALUATE: symbol $_1_DATA.DNAP_WATER_TOKEEP set to   0.750000     (real)
 CNSsolve>evaluate (&data.water_randfrac=&water_randfrac) 
 EVALUATE: symbol $_1_DATA.WATER_RANDFRAC set to    0.00000     (real)
 CNSsolve>evaluate (&data.solvate_method=&solvate_method) 
 EVALUATE: symbol $_1_DATA.SOLVATE_METHOD set to "db" (string)
 CNSsolve>evaluate (&data.water_surfcutoff=&water_surfcutoff) 
 EVALUATE: symbol $_1_DATA.WATER_SURFCUTOFF set to    8.00000     (real)
 CNSsolve>evaluate (&data.water_analysis=&water_analysis) 
 EVALUATE: symbol $_1_DATA.WATER_ANALYSIS set to FALSE (logical)
 CNSsolve>evaluate (&data.transwater=&transwater) 
 EVALUATE: symbol $_1_DATA.TRANSWATER set to TRUE (logical)
 CNSsolve>evaluate (&data.water_restraint_initial=&water_restraint_initial) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_INITIAL set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_cutoff=&water_restraint_cutoff) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_CUTOFF set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_scale=&water_restraint_scale) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_SCALE set to    25.0000     (real)
 CNSsolve>evaluate (&data.waterensemble=&waterensemble) 
 EVALUATE: symbol $_1_DATA.WATERENSEMBLE set to    1.00000     (real)
 CNSsolve> 
 CNSsolve>! Centroid parameters 
 CNSsolve>eval(&data.flags.centroids = &centroid_rest) 
 EVALUATE: symbol $_1_DATA.FLAGS.CENTROIDS set to FALSE (logical)
 CNSsolve>eval(&data.centroids.kscale = &centroid_kscale) 
 EVALUATE: symbol $_1_DATA.CENTROIDS.KSCALE set to    50.0000     (real)
 CNSsolve>eval($nchain = 0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>while ($nchain < &ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>    eval(&data.centroids.xcom_$nchain = &xcom_$nchain) 
 Assuming literal string "&XCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.XCOM_1 set to "&XCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ycom_$nchain = &ycom_$nchain) 
 Assuming literal string "&YCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.YCOM_1 set to "&YCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.zcom_$nchain = &zcom_$nchain) 
 Assuming literal string "&ZCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.ZCOM_1 set to "&ZCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ambi_$nchain = &ambi_$nchain) 
 Assuming literal string "&AMBI_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.AMBI_1 set to "&AMBI_$NCHAIN" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < &ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>    eval(&data.centroids.xcom_$nchain = &xcom_$nchain) 
 Assuming literal string "&XCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.XCOM_2 set to "&XCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ycom_$nchain = &ycom_$nchain) 
 Assuming literal string "&YCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.YCOM_2 set to "&YCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.zcom_$nchain = &zcom_$nchain) 
 Assuming literal string "&ZCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.ZCOM_2 set to "&ZCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ambi_$nchain = &ambi_$nchain) 
 Assuming literal string "&AMBI_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.AMBI_2 set to "&AMBI_$NCHAIN" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < &ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve>    eval(&data.centroids.xcom_$nchain = &xcom_$nchain) 
 CNSsolve>    eval(&data.centroids.ycom_$nchain = &ycom_$nchain) 
 CNSsolve>    eval(&data.centroids.zcom_$nchain = &zcom_$nchain) 
 CNSsolve>    eval(&data.centroids.ambi_$nchain = &ambi_$nchain) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>if (&saprotocol.expand eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval(&data.flags.centroids = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Cryo-EM parameters 
 CNSsolve>eval(&data.flags.em = &em_rest) 
 EVALUATE: symbol $_1_DATA.FLAGS.EM set to FALSE (logical)
 CNSsolve>eval(&data.em.kscale = &em_kscale) 
 EVALUATE: symbol $_1_DATA.EM.KSCALE set to    15000.0     (real)
 CNSsolve>eval(&data.em.it0 = &em_it0) 
 EVALUATE: symbol $_1_DATA.EM.IT0 set to FALSE (logical)
 CNSsolve>eval(&data.em.it1 = &em_it1) 
 EVALUATE: symbol $_1_DATA.EM.IT1 set to FALSE (logical)
 CNSsolve>eval(&data.em.itw = &em_itw) 
 EVALUATE: symbol $_1_DATA.EM.ITW set to FALSE (logical)
 CNSsolve>eval(&data.em.resolution = &em_resolution) 
 Assuming literal string "NONE"
 EVALUATE: symbol $_1_DATA.EM.RESOLUTION set to "NONE" (string)
 CNSsolve>eval(&data.em.nx = &nx) 
 EVALUATE: symbol $_1_DATA.EM.NX set to    32.0000     (real)
 CNSsolve>eval(&data.em.ny = &ny) 
 EVALUATE: symbol $_1_DATA.EM.NY set to    32.0000     (real)
 CNSsolve>eval(&data.em.nz = &nz) 
 EVALUATE: symbol $_1_DATA.EM.NZ set to    32.0000     (real)
 CNSsolve>eval(&data.em.xlength = &xlength) 
 EVALUATE: symbol $_1_DATA.EM.XLENGTH set to    80.0000     (real)
 CNSsolve>eval(&data.em.ylength = &ylength) 
 EVALUATE: symbol $_1_DATA.EM.YLENGTH set to    80.0000     (real)
 CNSsolve>eval(&data.em.zlength = &zlength) 
 EVALUATE: symbol $_1_DATA.EM.ZLENGTH set to    80.0000     (real)
 CNSsolve> 
 CNSsolve>if (&data.flags.em eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval(&data.waterdock = false) 
 CNSsolve>  display "EM restraints and solvated docking are incompatible - turning solvated docking OFF" 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>  evaluate (&SaProtocol.initiosteps = 0) 
 CNSsolve>  evaluate (&SaProtocol.cool1_steps = 0) 
 CNSsolve>  evaluate (&refine.keepwater = true) 
 CNSsolve>  display SOLVATED DOCKING TURNED ON: initiosteps and cool1_steps set to 0, rotate180 set to false 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Flexible region cutoff 
 CNSsolve>evaluate (&data.flcut_nb = &flcut_nb) 
 EVALUATE: symbol $_1_DATA.FLCUT_NB set to    5.00000     (real)
 CNSsolve>! set abort=off end 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve> evaluate ($chain =2) 
 EVALUATE: symbol $CHAIN set to    2.00000     (real)
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve> 
 CNSsolve> evaluate($topology_infile= "RUN:toppar/" + $Toppar.prot_top_$chain) 
 EVALUATE: symbol $TOPOLOGY_INFILE set to "RUN:toppar/protein-allhdg5-4.top" (string)
 CNSsolve> evaluate($parameter_infile= "RUN:toppar/" + $Toppar.prot_par_$chain) 
 EVALUATE: symbol $PARAMETER_INFILE set to "RUN:toppar/protein-allhdg5-4.param" (string)
 CNSsolve> evaluate($link_file= "RUN:toppar/" + $Toppar.prot_link_$chain) 
 EVALUATE: symbol $LINK_FILE set to "RUN:toppar/protein-allhdg5-4-noter.link" (string)
 CNSsolve> evaluate($coor_infile= "RUN:data/sequence/" + $Toppar.prot_coor_$chain) 
 EVALUATE: symbol $COOR_INFILE set to "RUN:data/sequence/protein2.pdb" (string)
 CNSsolve> evaluate($coor_inlist= "RUN:data/sequence/file_" + encode($chain) + ".list") 
 EVALUATE: symbol $COOR_INLIST set to "RUN:data/sequence/file_2.list" (string)
 CNSsolve> evaluate($coor_outfile= "BEGIN:" + $Toppar.prot_root_$chain + ".pdb") 
 EVALUATE: symbol $COOR_OUTFILE set to "BEGIN:protein2.pdb" (string)
 CNSsolve> evaluate($psf_outfile= "BEGIN:" + $Toppar.prot_root_$chain + ".psf") 
 EVALUATE: symbol $PSF_OUTFILE set to "BEGIN:protein2.psf" (string)
 CNSsolve> evaluate($psf2_outfile= "BEGIN:" + $Toppar.prot_coor_$chain - ".pdb" + ".psf") 
 EVALUATE: symbol $PSF2_OUTFILE set to "BEGIN:protein2.psf" (string)
 CNSsolve> evaluate($par_nonbonded= $Toppar.par_nonbonded) 
 EVALUATE: symbol $PAR_NONBONDED set to "OPLSX" (string)
 CNSsolve> 
 CNSsolve> if ($Toppar.prot_segid_$chain="") then 
 NEXTCD: condition evaluated as false
 CNSsolve>   evaluate($Toppar.prot_segid_$chain=encode($chain)) 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> evaluate ($log_level=normal) 
 Assuming literal string "NORMAL"
 EVALUATE: symbol $LOG_LEVEL set to "NORMAL" (string)
 CNSsolve> 
 CNSsolve> topology 
 RTFRDR>   @@$topology_infile 
 ASSFIL: file protein-allhdg5-4.top opened.
 RTFRDR>remarks file toppar/protein-allhdg5-4.top 
 RTFRDR>remarks 
 RTFRDR>remarks   file topallhdg.pro  version 5.4  date 07-July-10 
 RTFRDR>remarks      for file parallhdg.pro version 5.4 date 07-July-10 or later 
 RTFRDR>remarks   Geometric energy function parameters for distance geometry and 
 RTFRDR>remarks      simulated annealing. 
 RTFRDR>remarks   Author: Michael Nilges, EMBL Heidelberg; Institut Pasteur, Paris 
 RTFRDR>remarks   This file contains modifications from M. Williams, UCL London 
 RTFRDR>remarks   and multiple modifications for HADDOCK from A. Bonvin, Utrecht University 
 RTFRDR>remarks   Last modification 24-09-2014 
 RTFRDR> 
 RTFRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 RTFRDR>set message=off echo=off end 
 RTFRDR>   if ( &BLANK%ion_topology_infile = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>     @@&ion_topology_infile 
 ASSFIL: file ion.top opened.
 RTFRDR>remarks file toppar/ion.top 
 RTFRDR>remarks topology and masses for common ions 
 RTFRDR>remarks Dingle atom ion residues are given the name of the element. 
 RTFRDR>remarks By default the atom will be uncharged (eg. the residue MG will 
 RTFRDR>remarks contain the atom called MG with zero charge). 
 RTFRDR>remarks To use the charged species the charge state is appended to 
 RTFRDR>remarks the atom name (eg to use MG2+ the residue name is MG2, and the 
 RTFRDR>remarks atom name is MG+2 and has charge +2.0). 
 RTFRDR>remarks NOTE: not all ionic species are represented 
 RTFRDR>remarks PDA 02/09/99 
 RTFRDR> 
 RTFRDR>set echo=false end 
 RTFRDR>   end if 
 RTFRDR>   if ( &BLANK%nucl_topology_infile = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>     @@&nucl_topology_infile 
 ASSFIL: file dna-rna-allatom-hj-opls-1.3.top opened.
 RTFRDR>remarks file toppar/dna-rna-allatom-hj-opls-1.3 
 RTFRDR>remarks  all-hydrogen dna/rna topology using the OPLS force field 
 RTFRDR> 
 RTFRDR>!RNA TOPOLOGY FILE 'FRAMEWORK' FROM TOPALLHDG.DNA AND ATOM NAMES 
 RTFRDR>!  FROM DNA-RNA.PARAM 
 RTFRDR>!INCLUDES ALL NONEXCHANGEABLE HYDROGENS AND TERMS FOR BOND, ANGLE, AND 
 RTFRDR>!IMPROPERS. NONEXCHANGEABLE HYDROGEN CHARGES WERE ASSIGNED 0.035. 
 RTFRDR>!CARBON CHARGES WERE REDUCED 0.035 FOR EACH ATTACHED HYDROGEN. 
 RTFRDR>!CREATED 2/24/96-- JASON P. RIFE AND PETER B. MOORE 
 RTFRDR>!CHANGED TO OPLSX CHARGES 6/2/07 -- HENRY JONKER 
 RTFRDR>!ADAPTED/CLEANED FOR HADDOCK - ALEXANDRE BONVIN 
 RTFRDR> 
 RTFRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 RTFRDR>set message=off echo=off end 
 RTFRDR> 
 RTFRDR> 
 RTFRDR>   end if 
 RTFRDR>   if ( &BLANK%carbo_topology_infile = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>     @@&carbo_topology_infile 
 ASSFIL: file carbohydrate.top opened.
 RTFRDR>REMARKS toppar/carbohydrate.top 
 RTFRDR>REMARKS for use with carbohydrate.param for N-linked glycans 
 RTFRDR>REMARKS ========================================================== 
 RTFRDR>REMARKS Joao Rodrigues 11-June-2020 
 RTFRDR>REMARKS Topologies updated to Feng, PLoS One, 2017 
 RTFRDR>REMARKS PMC 5726640 
 RTFRDR>REMARKS Alexandre Bonvin July-2020 
 RTFRDR>REMARKS Patches added for GAL-SIA 2-3 and 2.6 linkages 
 RTFRDR>REMARKS ---------------------------------------------------------- 
 RTFRDR>REMARKS Currently supported carbohydrates and their anomers: 
 RTFRDR>REMARK (codes in parenthesis are commonly used alternatives - currently not recognized by CNS): 
 RTFRDR>REMARKS GLC:       alpha-D-glucopyranose 
 RTFRDR>REMARKS BGC:       beta -D-glucopyranose 
 RTFRDR>REMARKS GLA:       alpha-D-galactopyranose 
 RTFRDR>REMARKS GAL (GLB): beta- D-galactopyranose 
 RTFRDR>REMARKS MAN:       alpha-D-mannopyranose 
 RTFRDR>REMARKS BMA:       beta -D-mannopyronose 
 RTFRDR>REMARKS NDG:       2-N-acetyl-alpha-D-glucopyranose 
 RTFRDR>REMARKS A2G:       2-N-acetyl-alpha-D-glucopyranose, different stereochemistry at C4 
 RTFRDR>REMARKS NAG:       2-N-acetyl-beta-D-glucopyranose 
 RTFRDR>REMARKS NGA:       2-N-acetyl-beta-D-galactopyranose 
 RTFRDR>REMARKS FUC:       alpha-L-fucopyranose 
 RTFRDR>REMARKS FUL:       beta -L-fucopyranose 
 RTFRDR>REMARKS FCA:       alpha-D-fucopyranose 
 RTFRDR>REMARKS FCB:       beta -D-fucopyranose 
 RTFRDR>REMARKS SIA:       alpha-N-acetyl neuraminic acid 
 RTFRDR>REMARKS SIB:       beta-N-acetyl neuraminic acid - A. Bonvin 
 RTFRDR>REMARKS XYP:       beta-D-xylopyranose 
 RTFRDR>REMARKS ---------------------------------------------------------- 
 RTFRDR>REMARKS Links 
 RTFRDR>REMARKS B1N: N-linked glycan beta link from NAG and NDG to ASN (asparagine) 
 RTFRDR>!            note: PDB files with unusual NDG to ASN links are likely incorrect assignments 
 RTFRDR>!            they will be forced into the beta anomer by the B1N link. 
 RTFRDR>REMARKS B12: beta(1,2)  link from BGC, GAL, BMA, NAG, FCB, XYP to any 
 RTFRDR>REMARKS B14: beta(1,4)  link from BGC, GAL, BMA, NAG, FCB, XYP to any 
 RTFRDR>REMARKS A12: alpha(1,2) link from GLC, GLA, MAN, NDG, A2G, FCA to any 
 RTFRDR>REMARKS A13: alpha(1,3) link from GLC, GLA, MAN, NDG, A2G, FCA to any 
 RTFRDR>REMARKS A14: alpha(1,4) link from GLC, GLA, MAN, NDG, A2G, FCA to any 
 RTFRDR>REMARKS A16: alpha(1,6) link from GLC, GLA, MAN, NDG, A2G, FCA to any 
 RTFRDR>REMARKS B12L: beta(1,2)  link from FUL to any 
 RTFRDR>REMARKS B14L: beta(1,4)  link from FUL to any 
 RTFRDR>REMARKS A12L: alpha(1,2) link from FUC to any 
 RTFRDR>REMARKS A13L: alpha(1,3) link from FUC to any 
 RTFRDR>REMARKS A14L: alpha(1,4) link from FUC to any 
 RTFRDR>REMARKS A16L: alpha(1,6) link from FUC to any 
 RTFRDR>REMARKS A23: alpha(2,3) link from GAL to SIA, SIB 
 RTFRDR>REMARKS A23S: alpha(2,3) link from SIA to GAL 
 RTFRDR>REMARKS A26: alpha(2,6) link from GAL to SIA, SIB 
 RTFRDR>REMARKS A26S: alpha(2,6)  link from SIA, SIB to GAL 
 RTFRDR>REMARKS RAM: alpha-L-rhamnose 
 RTFRDR>REMARKS GXL: alpha-L-galactopyranose 
 RTFRDR>REMARKS B13: beta(1,3)  link from beta-D-sugar to any 
 RTFRDR>REMARKS B13L: beta(1,3)  link from beta-L-sugar to any 
 RTFRDR>REMARKS B16: beta(1,6)  link from beta-D-sugar to any 
 RTFRDR>REMARKS B16L: beta(1,6)  link from beta-L-sugar to any 
 RTFRDR>REMARKS B1S: beta link from C1(D-) to Ser OG. 
 RTFRDR>REMARKS A1S: alpha link from C1(D-) to Ser OG. 
 RTFRDR>REMARKS B1T: beta link from C1(D-) to Thr OG1. 
 RTFRDR>REMARKS A1T: alpha link from C1(D-) to Thr OG1. 
 RTFRDR>REMARKS B1C: beta link from C1(D-) to Cys SG. 
 RTFRDR>REMARKS A1C: alpha link from C1(D-) to Cys SG. 
 RTFRDR>REMARKS B1SL: beta link from C1(L-) to Ser OG. 
 RTFRDR>REMARKS A1SL: alpha link from C1(L-) to Ser OG. 
 RTFRDR>REMARKS B1TL: beta link from C1(L-) to Thr OG1. 
 RTFRDR>REMARKS A1TL: alpha link from C1(L-) to Thr OG1. 
 RTFRDR>REMARKS B1CL: beta link from C1(L-) to Cys SG. 
 RTFRDR>REMARKS A1CL: alpha link from C1(L-) to Cys SG. 
 RTFRDR> 
 RTFRDR>! History: 
 RTFRDR>! Bill Weis 10-July-1988: 
 RTFRDR>! Charges taken from John Brady's glucose topology file for ring, 
 RTFRDR>!   others from protein parameter file. 
 RTFRDR>! Idealized values for impropers at ring carbons to allow simple 
 RTFRDR>!   construction of various anomers/epimers. 
 RTFRDR>! Any other hexose or link can be easily constructed by analogy to these. 
 RTFRDR> 
 RTFRDR>! Additions 6-March-1992 Bill Weis for use with PARAM2.CHO 
 RTFRDR>! New atom types CCA, CCE,  OA for the C1 & O1 positions to account 
 RTFRDR>! for different bond and angle values due to the anomeric effect. 
 RTFRDR>! More accurate equilibrium values for bond angle around this oxygen 
 RTFRDR>! in glycosidic linkages.  CCE for equatorial O1, CCA for 
 RTFRDR>! axial O1.   For free sugar, keep OH1 as O1 atomtype; changed to OA 
 RTFRDR>! for linkages. 
 RTFRDR>! References: G.A. Jeffrey (1990) Acta Cryst B46, 89-103; 
 RTFRDR>! K. Hirotsu & A.Shimada, (1974) Bull. Chem. Soc. Japan, 47, 1872-1879. 
 RTFRDR>! 
 RTFRDR>! Additional CC6 atomtype for exocyclic carbon 5/11/92 
 RTFRDR>! New nomenclature, pairs of anomers for each pyranose sugar, generic links, ATB 12-Dec-2009 
 RTFRDR>! 
 RTFRDR>! added impropers that define anomers using non-hydrogen atoms, ATB 12/06/09 
 RTFRDR>! 
 RTFRDR>! added additional residues: FCA, FCB, A2G, ATB 12/07/09 
 RTFRDR> 
 RTFRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 RTFRDR>set message=off echo=off end 
 RTFRDR> 
 RTFRDR> 
 RTFRDR>   end if 
 RTFRDR>   if ( &BLANK%solv_topology_infile = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>     @@&solv_topology_infile 
 ASSFIL: file water-allhdg5-4.top opened.
 RTFRDR>remarks file toppar/water-allhdg5-4.top 
 RTFRDR>remarks 
 RTFRDR>remarks  TOPH19.SOL 
 RTFRDR>remarks  ========== 
 RTFRDR>remarks  topology file for solvent molecules 
 RTFRDR>remarks  water models available: TIP3P model 
 RTFRDR> 
 RTFRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 RTFRDR>set message=off echo=off end 
 RTFRDR> 
 RTFRDR>   end if 
 RTFRDR>   if ( &BLANK%ligands_topology_infile = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>     @@&ligands_topology_infile 
 ASSFIL: file fragment_probes.top opened.
 RTFRDR>Remarks Parameters for Fragment-based Ligand Binding Site Mapping 
 RTFRDR>Remarks created by acpype (Rev: 7268) on Mon Apr 13 10:01:53 2015 
 RTFRDR> 
 RTFRDR>set echo=false end 
 RTFRDR>   end if 
 RTFRDR>   if ( &BLANK%cofac_topology_infile = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>     @@&cofac_topology_infile 
 ASSFIL: file ligand.top opened.
 RTFRDR>   if ( &BLANK%heme_topology_infile = false ) then 
 NEXTCD: condition evaluated as true
 RTFRDR>     @@&heme_topology_infile 
 ASSFIL: file hemes-allhdg.top opened.
 RTFRDR>remark file topallhdg.hemes 
 RTFRDR> 
 RTFRDR>set message off echo off end 
 RTFRDR>   end if 
 RTFRDR>   if ( &BLANK%prot_break_infile = false ) then 
 RTFRDR>     @@&prot_break_infile 
 RTFRDR>remarks file toppar/protein_break.top 
 RTFRDR>remarks   patches to remove peptide linkages 
 RTFRDR> 
 RTFRDR>! Paul Adams 28th June 1999 
 RTFRDR>! Yale University 
 RTFRDR> 
 RTFRDR>set echo=false end 
 %RTFRDR-ERR: duplicate (P-)RESIdue name DPEP
 %RTFRDR-ERR: duplicate (P-)RESIdue name DPPP
 RTFRDR> 
 RTFRDR>   end if 
 RTFRDR>   if ( &BLANK%dna_break_infile = false ) then 
 RTFRDR>     @@&dna_break_infile 
 RTFRDR>PRESidue DNUC        ! patch for deletion of nucleic acid linkage 
 RESIDUE>                     ! i.e. it deletes the link the previous RNA residue (-) with 
 RESIDUE>                     ! the current one (+) 
 RESIDUE> DELETE BOND -O3' +P 
 RESIDUE> DELETE ANGLE -C3' -O3' +P 
 RESIDUE> DELETE ANGLE -O3' +P  +OP1 
 RESIDUE> DELETE ANGLE -O3' +P  +O1P 
 RESIDUE> DELETE ANGLE -O3' +P  +OP2 
 RESIDUE> DELETE ANGLE -O3' +P  +O2P 
 RESIDUE> DELETE ANGLE -O3' +P  +O5' 
 RESIDUE> 
 RESIDUE>END {DNUC} 
 RTFRDR> 
 RTFRDR> 
 RTFRDR>   end if 
 RTFRDR> end 
 CNSsolve> 
 CNSsolve> parameter 
 PARRDR>   @@$parameter_infile 
 PARRDR>remarks file toppar/protein-allhdg5-4.param 
 PARRDR>remark 
 PARRDR>remark   for file protein-allhdg-ucl.top  version UCL  date 14-MAR-00 
 PARRDR>remark   for file protein-allhdg-dih-ucl.top  version UCL  date 07-JUL-01 
 PARRDR>remark   Geometric energy function parameters for distance geometry and 
 PARRDR>remark   simulated annealing. 
 PARRDR>remark   Original author: Michael Nilges, EMBL Heidelberg 
 PARRDR>remark   Modifications: Mark A. Williams, UCL London 
 PARRDR>remark   Several modifications for HADDOCK: Alexandre Bonvin, Utrecht Uni 
 PARRDR>remark   Last modification 06-02-2021 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR> 
 PARRDR>   if ( &BLANK%ion_parameter_infile = false ) then 
 PARRDR>     @@&ion_parameter_infile 
 PARRDR>remarks file toppar/ion.param 
 PARRDR>remarks nonbonded parameters for common ions 
 PARRDR>remarks new parameters derived from literature for single atom species 
 PARRDR>remarks PDA 02/09/99 
 PARRDR> 
 PARRDR>set echo=off end 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%nucl_parameter_infile = false ) then 
 PARRDR>     @@&nucl_parameter_infile 
 PARRDR>remarks file toppar/dna-rna-allatom.top 
 PARRDR>remarks  dna-rna-allatom-hj-opls-1.3.param 
 PARRDR>remarks  all-hydrogen dna/rna parameters using the OPLS force field 
 PARRDR> 
 PARRDR>!RNA PARAMETER FILE 'FRAMEWORK' FROM PARALLHDG.DNA AND ATOM NAMES 
 PARRDR>! AND HEAVY ATOM PARAMETERS FROM DNA-RNA.PARAM 
 PARRDR>!INCLUDES ALL NONEXCHANGEABLE HYDROGEN TERMS FOR BOND, ANGLE, AND 
 PARRDR>!IMPROPERS WITH ENERGY CONSTANT VARIABLES: $kchbond, $kchangle, AND $kchimpr. 
 PARRDR>!BOND, ANGLE, AND IMPROPERS WERE ESTIMATED FROM VALUES FROM THE STANDARD 
 PARRDR>!NUCLEOTIDES OF INSIGHTII 95.0 (BIOSYM/MOLECULAR SIMULATIONS). 
 PARRDR>!CREATED 2/24/96 -- JASON P. RIFE AND PETER B. MOORE 
 PARRDR>!ADDED OPLSX SECTION 6/2/07 -- HENRY JONKER 
 PARRDR>!ADAPTED/CLEANED FOR HADDOCK -- ALEXANDRE BONVIN 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%carbo_parameter_infile = false ) then 
 PARRDR>     @@&carbo_parameter_infile 
 PARRDR>remarks file toppar/carbohydrate.param 
 PARRDR>REMARKS Parameter file for pyranose sugars 
 PARRDR>REMARKS Alexandre Bonvin - adapted to use unique atom types for sugar-specific atoms 
 PARRDR>REMARKS Joao Rodrigues 11-June-2020 
 PARRDR>REMARKS Parameters updated to Feng, PLoS One, 2017 
 PARRDR>REMARKS PMC 5726640 
 PARRDR> 
 PARRDR>REMARKS Bill Weis 10-July-1988 
 PARRDR>REMARKS Additions for atom type combinations not covered in PARAM19X.PRO. 
 PARRDR>REMARKS Needed additions are for ether oxygen and aliphatic carbon in all-atom 
 PARRDR>REMARKS representation used for sugars (type CC).  Ditto for type HA. 
 PARRDR>REMARKS Values from J. Brady glucose parameters unless noted. 
 PARRDR>REMARKS These should be sufficient for refinement. 
 PARRDR> 
 PARRDR>REMARKS Additions 6-March-1992 Bill Weis 
 PARRDR>REMARKS New atom types CCA, CCE,  OASfor the C1 & O1 positions to account 
 PARRDR>REMARKS for different BOND and ANGLe values due to the anomeric effect. 
 PARRDR>REMARKS More accurate equilibrium values for BOND ANGLe around this oxygen 
 PARRDR>REMARKS in glycosidic linkages.  CCE for equatorial O1, CCA for 
 PARRDR>REMAKRS axial O1.   For free sugar, keep OH1 as O1 atomtype; changed to OA 
 PARRDR>REMARKS for linkages. 
 PARRDR>REMARKS References: G.A. Jeffrey (1990) Acta Cryst B46, 89-103; 
 PARRDR>REMARKS K. Hirotsu & A.Shimada, (1974) Bull. Chem. Soc. Japan, 47, 1872-1879. 
 PARRDR> 
 PARRDR>REMARKS  This set has been modified to be roughly consistent with 
 PARRDR>REMARKS  the csd-derived protein parameters of Engh and Huber. 
 PARRDR>REMARKS  New atom type CC6 for exocyclic 6 carbon 
 PARRDR>REMARKS  Bill Weis 5/11/92 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR> 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%solv_parameter_infile = false ) then 
 PARRDR>     @@&solv_parameter_infile 
 PARRDR>remarks file toppar/water-allhdg5-4.param 
 PARRDR>remarks 
 PARRDR>remarks   PARAM19.SOL (solvent parameters) 
 PARRDR>remarks   =========== 
 PARRDR>remarks   available: TIPS3P and DMSO model 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 PARRDR>set message=off echo=off end 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%ligands_parameter_infile = false ) then 
 PARRDR>     @@&ligands_parameter_infile 
 PARRDR>Remarks Parameters for Fragment-based Ligand Binding Site Mapping 
 PARRDR>Remarks created by acpype (Rev: 7268) on Mon Apr 13 10:01:53 2015 
 PARRDR> 
 PARRDR>set echo=false end 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%cofac_parameter_infile = false ) then 
 PARRDR>     @@&cofac_parameter_infile 
 PARRDR>   if ( &BLANK%heme_parameter_infile = false ) then 
 PARRDR>     @@&heme_parameter_infile 
 PARRDR>remark  file parallhdg.hemes 
 PARRDR> 
 PARRDR>set message off echo off end 
 PARRDR>   end if 
 PARRDR> end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve> 
 CNSsolve> segment 
 SEGMENT>   chain 
 CHAIN>     if ( &convert = true ) then 
 NEXTCD: condition evaluated as false
 CHAIN>       convert=true 
 CHAIN>     end if 
 CHAIN>     if ( &separate = true ) then 
 NEXTCD: condition evaluated as true
 CHAIN>       separate=true 
 CHAIN>     end if 
 CHAIN>     if ( $Toppar.dna_$chain = false) then 
 NEXTCD: condition evaluated as true
 CHAIN>       if ( &BLANK%nucl_link_infile = false ) then 
 NEXTCD: condition evaluated as true
 CHAIN>         @@&nucl_link_infile 
 ASSFIL: file dna-rna-1.3.link opened.
 CHAIN>remarks file toppar/dna-rna.link 
 CHAIN>remarks macro to define standard nucleic acid links and termini 
 CHAIN>remarks this file has both 3' and 5' terminii without phosphate groups 
 CHAIN>remarks 
 CHAIN> 
 CHAIN>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 CHAIN>set message=off echo=off end 
 CHAIN>       end if 
 CHAIN>     end if 
 CHAIN>     if ( &BLANK%cofac_link_infile = false ) then 
 NEXTCD: condition evaluated as true
 CHAIN>       @@&cofac_link_infile 
 ASSFIL: file ligand.pep opened.
 CHAIN>     @@$link_file 
 ASSFIL: file protein-allhdg5-4-noter.link opened.
 CHAIN>remarks file toppar/protein-allhdg5-4.link 
 CHAIN>remarks 
 CHAIN>remarks this is a macro to define standard protein peptide bonds 
 CHAIN>remarks and termini to generate a protein sequence. 
 CHAIN> 
 CHAIN>!added links for MSE (8-19-2011, ATB) 
 CHAIN>!added links for CFE (6-5-2014, AB) 
 CHAIN> 
 CHAIN>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 CHAIN>set message=off echo=off end 
 CHAIN> 
 CHAIN>     coordinates @@$coor_infile 
 ASSFIL: file protein2.pdb opened.
 COOR>ATOM      1  N   MET     2     -25.126 -15.124  33.576  1.00 35.36 
 SEGMNT-info: chain termination due to TER keyword.     5 residues were inserted into segid "    "
 COOR>END 
 CHAIN>   end 
 SEGMENT> end 
 Status of internal molecular topology database:
 -> NATOM=        103(MAXA=     1000000)  NBOND=        107(MAXB=     1000000)
 -> NTHETA=       189(MAXT=     2000000)  NGRP=           5(MAXGRP=   1000000)
 -> NPHI=          96(MAXP=     2000000)  NIMPHI=        77(MAXIMP=   1000000)
 -> NNB=           12(MAXNB=    1000000) 
 CNSsolve> 
 CNSsolve> coordinates @@$coor_infile end 
 ASSFIL: file protein2.pdb opened.
 COOR>ATOM      1  N   MET     2     -25.126 -15.124  33.576  1.00 35.36 
 COOR>ATOM      2  CA  MET     2     -24.995 -13.787  34.278  1.00 34.28 
 %READC-ERR: atom      6    TRP  OXT  not found in molecular structure
 %READC-WRN: still     49 missing coordinates (in selected subset)
 CNSsolve> end 
 %CNS-ERR: "END" not allowed. "STOP" terminates program
 CNSsolve> 
 CNSsolve> ! next line to remove the MAP atom defined in the DUM residue 
 CNSsolve> ! in case of use of dummy particles 
 CNSsolve> delete sele=(name MAP) end 
 SELRPN:      0 atoms have been selected out of    103
 Status of internal molecular topology database:
 -> NATOM=        103(MAXA=     1000000)  NBOND=        107(MAXB=     1000000)
 -> NTHETA=       189(MAXT=     2000000)  NGRP=           5(MAXGRP=   1000000)
 -> NPHI=          96(MAXP=     2000000)  NIMPHI=        77(MAXIMP=   1000000)
 -> NNB=           12(MAXNB=    1000000) 
 CNSsolve> 
 CNSsolve> if ( &BLANK%ile_CD_becomes = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   do (name=&ile_CD_becomes) (resn ILE and name CD) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> end if 
 CNSsolve> if ( &BLANK%OT1_becomes = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   do (name=&OT1_becomes) (name OT1) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> end if 
 CNSsolve> if ( &BLANK%OT2_becomes = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   do (name=&OT2_becomes) (name OT2) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> !for the histidine patches: 
 CNSsolve> if ($Toppar.autohis = false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   evaluate($hisd_counter=1) 
 EVALUATE: symbol $HISD_COUNTER set to    1.00000     (real)
 CNSsolve>   while ($hisd_counter le $Toppar.nhisd_$chain) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ($Toppar.hisd_resid_$chain_$hisd_counter > 0) then 
 CNSsolve>       show (resn) (tag and resid $Toppar.hisd_resid_$chain_$hisd_counter) 
 CNSsolve>       if ($result eq "HIS") then 
 CNSsolve>         patch hisd reference=nil=(resid $Toppar.hisd_resid_$chain_$hisd_counter) end 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve>     evaluate($hisd_counter=$hisd_counter + 1) 
 CNSsolve>   end loop hisd 
 CNSsolve> 
 CNSsolve>   evaluate($hise_counter=1) 
 EVALUATE: symbol $HISE_COUNTER set to    1.00000     (real)
 CNSsolve>   while ($hise_counter le $Toppar.nhise_$chain) loop hise 
 NEXTCD: condition evaluated as false
 CNSsolve>     if ($Toppar.hise_resid_$chain_$hise_counter > 0) then 
 CNSsolve>       show (resn) (tag and resid $Toppar.hise_resid_$chain_$hise_counter) 
 CNSsolve>       if ($result eq "HIS") then 
 CNSsolve>         patch hise reference=nil=(resid $Toppar.hise_resid_$chain_$hise_counter) end 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve>     evaluate($hise_counter=$hise_counter + 1) 
 CNSsolve>   end loop hise 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve>! The following patches would define covalent bond between a CA+2 and oxygen ligands 
 CNSsolve>! from Asp and Glu (first selection is amino-acid, second is ion) 
 CNSsolve>! patch dca2 refe=1=(resid 25) refe=2=(resid 83) end 
 CNSsolve>! patch dca2 refe=1=(resid 29) refe=2=(resid 83) end 
 CNSsolve>! patch dca2 refe=1=(resid 35) refe=2=(resid 83) end 
 CNSsolve>! patch eca2 refe=1=(resid 36) refe=2=(resid 83) end 
 CNSsolve>! 
 CNSsolve>! following patch is to attach a heme (resid YY) CAB atom to a cys (resid XX) 
 CNSsolve>! patch phcb refe=1=(resid XX) refe=2=(resid YY) end 
 CNSsolve>! following patch is to attach a heme (resid YY) CAC atom to a cys (resid XX) 
 CNSsolve>! patch phcc refe=1=(resid XX) refe=2=(resid YY) end 
 CNSsolve>! 
 CNSsolve>! following patch is to define an isopeptide bond between a Cter and a Lys side-chain 
 CNSsolve>! patch clys refe=1=(resid 72) refe=2=(resid 148) end 
 CNSsolve>! 
 CNSsolve>! following patch is to define an isopeptide bond between a Cter and a Lys side-chain 
 CNSsolve>! patch clys refe=1=(resid 72) refe=2=(resid 148) end 
 CNSsolve> 
 CNSsolve> ! N-linked glycosylation patches 
 CNSsolve> inline @RUN:protocols/bondglycans.cns 
 ASSFIL: file bondglycans.cns opened.
 CNSsolve>! 
 CNSsolve>! Patches covalent bonds involving N-linked carbohydrates. 
 CNSsolve>! 
 CNSsolve>! Adapted from CNS 1.3 
 CNSsolve>!   modules/xtal/mtfautogenerate 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2020      Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>checkversion 1.3 
 Program version= 1.3 File version= 1.3
 CNSsolve> 
 CNSsolve>display 

 CNSsolve>display  autogenerating linkages involving N-linked carbohydrates 
 autogenerating linkages involving N-linked carbohydrates
 CNSsolve>display 

 CNSsolve> 
 CNSsolve>define 
 DEFINE>( 
 DEFINE>  {- define all alpha anomer carbo residues for the links below -} 
 DEFINE>  alpha=   ( resname GLC or resname GLA or resname MAN or resname NDG or resname A2G or resname FUC or resname FCA ); 
 DEFINE> 
 DEFINE>  {- define all beta anomer carbo residues for the links below -} 
 DEFINE>  beta=    ( resname BGC or resname GAL or resname BMA or resname NAG or resname NGA or resname FUL or resname FCB or resname XYP ); 
 DEFINE> 
 DEFINE>  {- Maximum distance between linkable atoms -} 
 DEFINE>  carbo_dist= 2.75; 
 DEFINE>) 
 CNSsolve> 
 CNSsolve>{- this is OK here after reading the coordinates since the various -} 
 CNSsolve>{- patches used here do not create or rename atoms -} 
 CNSsolve> 
 CNSsolve>{- first we build a data structure for the patches, and then apply the patches later -} 
 CNSsolve>{- the reason we do it this way is that patch may delete or add atoms which will currently 
 CNSsolve>   reset the STORE and loop arrays -} 
 CNSsolve> 
 CNSsolve>eval ($npatch=0) 
 EVALUATE: symbol $NPATCH set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>{- NAG-C2 (or NDG-C2) (or BGC-C2) to ASN-ND2 -} 
 CNSsolve>for $id1 in id ( (resname NAG or resname NDG or resname BGC) and name C1 and known ) loop B1Na 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>  show (segid) (id $id1) 
 CNSsolve>  evaluate ($segid1=$result) 
 CNSsolve>  show (resid) (id $id1) 
 CNSsolve>  evaluate ($resid1=$result) 
 CNSsolve>  show (resname) (id $id1) 
 CNSsolve>  evaluate ($resname1=$result) 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( resname ASN and name ND2 and known ) loop B1Nb 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>    show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>    show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>    show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>    show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>    show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>    evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>    if ( $distance <= &carbo_dist ) then 
 CNSsolve>       evaluate ($npatch=$npatch+1) 
 CNSsolve>       evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>       evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>       evaluate ($res1.$npatch=$resid1) 
 CNSsolve>       evaluate ($res2.$npatch=$resid2) 
 CNSsolve>       if ($resname1="NDG") then 
 CNSsolve>          evaluate ($pres.$npatch="B1N")  ! force to beta anomer, ATB 02/03/2010 
 CNSsolve>          display   warning: unusual NDG to ASN patch for NDG segid= $segid1 resid= $resid1 - forced to beta anomer 
 CNSsolve>       else 
 CNSsolve>          evaluate ($pres.$npatch="B1N") 
 CNSsolve>       end if 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>  end loop B1Nb 
 CNSsolve> 
 CNSsolve>end loop B1Na 
 CNSsolve> 
 CNSsolve>{- A23: GAL to SIA, SIB -} 
 CNSsolve>for $id1 in id ( resname GAL and name C2 and known ) loop A23a 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>  show (segid) (id $id1) 
 CNSsolve>  evaluate ($segid1=$result) 
 CNSsolve>  show (resid) (id $id1) 
 CNSsolve>  evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( (resname SIA or resname SIB) and name O3 and known ) loop A23b 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>    show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>    show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>    show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>    show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>    show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>    evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>    if ( $distance <= &carbo_dist ) then 
 CNSsolve>       evaluate ($npatch=$npatch+1) 
 CNSsolve>       evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>       evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>       evaluate ($res1.$npatch=$resid1) 
 CNSsolve>       evaluate ($res2.$npatch=$resid2) 
 CNSsolve>       evaluate ($pres.$npatch="A23") 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>  end loop A23b 
 CNSsolve> 
 CNSsolve>end loop A23a 
 CNSsolve> 
 CNSsolve>{- A23: SIA,SIB to GAL -} 
 CNSsolve>for $id1 in id ( (resname SIA or resname SIB) and name C2 and known ) loop A23c 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>  show (segid) (id $id1) 
 CNSsolve>  evaluate ($segid1=$result) 
 CNSsolve>  show (resid) (id $id1) 
 CNSsolve>  evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( resname GAL and name O3 and known ) loop A23d 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>    show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>    show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>    show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>    show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>    show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>    evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>    if ( $distance <= &carbo_dist ) then 
 CNSsolve>       evaluate ($npatch=$npatch+1) 
 CNSsolve>       evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>       evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>       evaluate ($res1.$npatch=$resid1) 
 CNSsolve>       evaluate ($res2.$npatch=$resid2) 
 CNSsolve>       evaluate ($pres.$npatch="A23") 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>  end loop A23d 
 CNSsolve> 
 CNSsolve>end loop A23c 
 CNSsolve> 
 CNSsolve>{- A26: GAL to SIA,SIB -} 
 CNSsolve>for $id1 in id ( resname GAL and name C2 and known ) loop A26a 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>  show (segid) (id $id1) 
 CNSsolve>  evaluate ($segid1=$result) 
 CNSsolve>  show (resid) (id $id1) 
 CNSsolve>  evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( (resname SIA or resname SIB) and name O6 and known ) loop A26b 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>    show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>    show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>    show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>    show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>    show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>    evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>    if ( $distance <= &carbo_dist ) then 
 CNSsolve>       evaluate ($npatch=$npatch+1) 
 CNSsolve>       evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>       evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>       evaluate ($res1.$npatch=$resid1) 
 CNSsolve>       evaluate ($res2.$npatch=$resid2) 
 CNSsolve>       evaluate ($pres.$npatch="A26") 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>  end loop A26b 
 CNSsolve> 
 CNSsolve>end loop A26a 
 CNSsolve> 
 CNSsolve>{- A26: SIA,SIB to GAL -} 
 CNSsolve>for $id1 in id ( (resname SIA or resname SIB) and name C2 and known ) loop A26c 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>  show (segid) (id $id1) 
 CNSsolve>  evaluate ($segid1=$result) 
 CNSsolve>  show (resid) (id $id1) 
 CNSsolve>  evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( resname GAL and name O6 and known ) loop A26d 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>    show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>    show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>    show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>    show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>    show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>    evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>    if ( $distance <= &carbo_dist ) then 
 CNSsolve>       evaluate ($npatch=$npatch+1) 
 CNSsolve>       evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>       evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>       evaluate ($res1.$npatch=$resid1) 
 CNSsolve>       evaluate ($res2.$npatch=$resid2) 
 CNSsolve>       evaluate ($pres.$npatch="A26S") 
 CNSsolve>   end if 
 CNSsolve> 
 CNSsolve>  end loop A26d 
 CNSsolve> 
 CNSsolve>end loop A26c 
 CNSsolve> 
 CNSsolve>{- now the beta-anomer to any links -} 
 CNSsolve>{- for B12: beta(1,2)  link from beta-anomer to any -} 
 CNSsolve>ident (store2) ( ( &alpha or &beta ) and name O2 and known ) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve>{- for B13: beta(1,3)  link from beta-anomer to any -} 
 CNSsolve>ident (store3) ( ( &alpha or &beta ) and name O3 and known ) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve>{- for B14: beta(1,4)  link from beta-anomer to any -} 
 CNSsolve>ident (store4) ( ( &alpha or &beta ) and name O4 and known ) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>for $id1 in id ( &beta and name C1 and known ) loop B1 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>  show (segid) (id $id1) 
 CNSsolve>  evaluate ($segid1=$result) 
 CNSsolve>  show (resid) (id $id1) 
 CNSsolve>  evaluate ($resid1=$result) 
 CNSsolve>  show (resname) (id $id1) 
 CNSsolve>  evaluate ($resname1=$result) 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( recall2 ) loop B12 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    evaluate ($identical=false) 
 CNSsolve>    if ($resid1 = $resid2) then 
 CNSsolve>        if ($segid1 = $segid2) then 
 CNSsolve>           evaluate ($identical=true) 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($identical=false) then 
 CNSsolve> 
 CNSsolve>       show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>       show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>       show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>       show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>       show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>       show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>       evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>       if ( $distance <= &carbo_dist ) then 
 CNSsolve>          evaluate ($npatch=$npatch+1) 
 CNSsolve>          evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>          evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>          evaluate ($res1.$npatch=$resid1) 
 CNSsolve>          evaluate ($res2.$npatch=$resid2) 
 CNSsolve>          if ($resname1="FUL") then 
 CNSsolve>             evaluate ($pres.$npatch="B12L") 
 CNSsolve>          else 
 CNSsolve>             evaluate ($pres.$npatch="B12") 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop B12 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( recall3 ) loop B13 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    evaluate ($identical=false) 
 CNSsolve>    if ($resid1 = $resid2) then 
 CNSsolve>        if ($segid1 = $segid2) then 
 CNSsolve>           evaluate ($identical=true) 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($identical=false) then 
 CNSsolve> 
 CNSsolve>       show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>       show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>       show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>       show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>       show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>       show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>       evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>       if ( $distance <= &carbo_dist ) then 
 CNSsolve>          evaluate ($npatch=$npatch+1) 
 CNSsolve>          evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>          evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>          evaluate ($res1.$npatch=$resid1) 
 CNSsolve>          evaluate ($res2.$npatch=$resid2) 
 CNSsolve>          if ($resname1="FUL") then 
 CNSsolve>             evaluate ($pres.$npatch="B13L") 
 CNSsolve>          else 
 CNSsolve>             evaluate ($pres.$npatch="B13") 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop B13 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( recall4 ) loop B14 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    evaluate ($identical=false) 
 CNSsolve>    if ($resid1 = $resid2) then 
 CNSsolve>        if ($segid1 = $segid2) then 
 CNSsolve>           evaluate ($identical=true) 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($identical=false) then 
 CNSsolve> 
 CNSsolve>      show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>      show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>      show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>      show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>      show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>      show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>      evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>      if ( $distance <= &carbo_dist ) then 
 CNSsolve>          evaluate ($npatch=$npatch+1) 
 CNSsolve>          evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>          evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>          evaluate ($res1.$npatch=$resid1) 
 CNSsolve>          evaluate ($res2.$npatch=$resid2) 
 CNSsolve>          if ($resname1="FUL") then 
 CNSsolve>             evaluate ($pres.$npatch="B14L") 
 CNSsolve>          else 
 CNSsolve>             evaluate ($pres.$npatch="B14") 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop B14 
 CNSsolve> 
 CNSsolve>end loop B1 
 CNSsolve> 
 CNSsolve>{- now the alpha anomer to any links -} 
 CNSsolve>{- for A12: alpha(1,2)  link from alpha-anomer to any -} 
 CNSsolve>ident (store2) ( ( &alpha or &beta) and name O2 and known ) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve>{- for A13: alpha(1,3)  link from alpha-anomer to any -} 
 CNSsolve>ident (store3) ( ( &alpha or &beta) and name O3 and known ) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve>{- for A14: alpha(1,4)  link from alpha-anomer to any -} 
 CNSsolve>ident (store4) ( ( &alpha or &beta) and name O4 and known ) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve>{- for A16: alpha(1,6)  link from alpha-anomer to any -} 
 CNSsolve>ident (store6) ( ( &alpha or &beta) and name O6 and known ) 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>for $id1 in id ( &alpha and name C1 and known ) loop A1 
 SELRPN:      0 atoms have been selected out of    103
 CNSsolve> 
 CNSsolve>  show (segid) (id $id1) 
 CNSsolve>  evaluate ($segid1=$result) 
 CNSsolve>  show (resid) (id $id1) 
 CNSsolve>  evaluate ($resid1=$result) 
 CNSsolve>  show (resname) (id $id1) 
 CNSsolve>  evaluate ($resname1=$result) 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( recall2 ) loop A12 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    evaluate ($identical=false) 
 CNSsolve>    if ($resid1 = $resid2) then 
 CNSsolve>        if ($segid1 = $segid2) then 
 CNSsolve>           evaluate ($identical=true) 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($identical=false) then 
 CNSsolve> 
 CNSsolve>       show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>       show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>       show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>       show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>       show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>       show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>       evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>       if ( $distance <= &carbo_dist ) then 
 CNSsolve>          evaluate ($npatch=$npatch+1) 
 CNSsolve>          evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>          evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>          evaluate ($res1.$npatch=$resid1) 
 CNSsolve>          evaluate ($res2.$npatch=$resid2) 
 CNSsolve>          if ($resname1="FUC") then 
 CNSsolve>             evaluate ($pres.$npatch="A12L") 
 CNSsolve>          else 
 CNSsolve>             evaluate ($pres.$npatch="A12") 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop A12 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( recall3 ) loop A13 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    evaluate ($identical=false) 
 CNSsolve>    if ($resid1 = $resid2) then 
 CNSsolve>        if ($segid1 = $segid2) then 
 CNSsolve>           evaluate ($identical=true) 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($identical=false) then 
 CNSsolve> 
 CNSsolve>       show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>       show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>       show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>       show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>       show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>       show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>       evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>       if ( $distance <= &carbo_dist ) then 
 CNSsolve>          evaluate ($npatch=$npatch+1) 
 CNSsolve>          evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>          evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>          evaluate ($res1.$npatch=$resid1) 
 CNSsolve>          evaluate ($res2.$npatch=$resid2) 
 CNSsolve>          if ($resname1="FUC") then 
 CNSsolve>             evaluate ($pres.$npatch="A13L") 
 CNSsolve>          else 
 CNSsolve>             evaluate ($pres.$npatch="A13") 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop A13 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( recall4 ) loop A14 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    evaluate ($identical=false) 
 CNSsolve>    if ($resid1 = $resid2) then 
 CNSsolve>        if ($segid1 = $segid2) then 
 CNSsolve>           evaluate ($identical=true) 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($identical=false) then 
 CNSsolve> 
 CNSsolve>       show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>       show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>       show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>       show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>       show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>       show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>       evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>       if ( $distance <= &carbo_dist ) then 
 CNSsolve>          evaluate ($npatch=$npatch+1) 
 CNSsolve>          evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>          evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>          evaluate ($res1.$npatch=$resid1) 
 CNSsolve>          evaluate ($res2.$npatch=$resid2) 
 CNSsolve>          if ($resname1="FUC") then 
 CNSsolve>             evaluate ($pres.$npatch="A14L") 
 CNSsolve>          else 
 CNSsolve>             evaluate ($pres.$npatch="A14") 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop A14 
 CNSsolve> 
 CNSsolve>  for $id2 in id ( recall6 ) loop A16 
 CNSsolve> 
 CNSsolve>    show (segid) (id $id2) 
 CNSsolve>    evaluate ($segid2=$result) 
 CNSsolve>    show (resid) (id $id2) 
 CNSsolve>    evaluate ($resid2=$result) 
 CNSsolve> 
 CNSsolve>    evaluate ($identical=false) 
 CNSsolve>    if ($resid1 = $resid2) then 
 CNSsolve>        if ($segid1 = $segid2) then 
 CNSsolve>           evaluate ($identical=true) 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($identical=false) then 
 CNSsolve>       show (x) ( id $id1 ) evaluate ($x1=$result) 
 CNSsolve>       show (y) ( id $id1 ) evaluate ($y1=$result) 
 CNSsolve>       show (z) ( id $id1 ) evaluate ($z1=$result) 
 CNSsolve>       show (x) ( id $id2 ) evaluate ($x2=$result) 
 CNSsolve>       show (y) ( id $id2 ) evaluate ($y2=$result) 
 CNSsolve>       show (z) ( id $id2 ) evaluate ($z2=$result) 
 CNSsolve>       evaluate ($distance=sqrt( ($x1-$x2)^2 + ($y1-$y2)^2 + ($z1-$z2)^2 )) 
 CNSsolve> 
 CNSsolve>       if ( $distance <= &carbo_dist ) then 
 CNSsolve>          evaluate ($npatch=$npatch+1) 
 CNSsolve>          evaluate ($seg1.$npatch=$segid1) 
 CNSsolve>          evaluate ($seg2.$npatch=$segid2) 
 CNSsolve>          evaluate ($res1.$npatch=$resid1) 
 CNSsolve>          evaluate ($res2.$npatch=$resid2) 
 CNSsolve>          if ($resname1="FUC") then 
 CNSsolve>             evaluate ($pres.$npatch="A16L") 
 CNSsolve>          else 
 CNSsolve>             evaluate ($pres.$npatch="A16") 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop A16 
 CNSsolve> 
 CNSsolve>end loop A1 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{- now we apply all the patches -} 
 CNSsolve>evaluate ($counter=1) 
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 CNSsolve>while ( $counter <= $npatch ) loop patc 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>   patch $pres.$counter 
 CNSsolve>      reference=-=(segid $seg1.$counter and resid $res1.$counter) 
 CNSsolve>      reference=+=(segid $seg2.$counter and resid $res2.$counter) 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve>   display  $pres.$counter link added: $seg1.$counter[a4] $res1.$counter[a4] to $seg2.$counter[a4] $res2.$counter[a4] 
 CNSsolve>   evaluate ($counter=$counter+1) 
 CNSsolve>end loop patc 
 CNSsolve> 
 CNSsolve> if ($Toppar.delenph = true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   delete sele=(name H* and attr charge = 0) end 
 SELRPN:     38 atoms have been selected out of    103
 Status of internal molecular topology database:
 -> NATOM=         65(MAXA=     1000000)  NBOND=         69(MAXB=     1000000)
 -> NTHETA=        98(MAXT=     2000000)  NGRP=           5(MAXGRP=   1000000)
 -> NPHI=          95(MAXP=     2000000)  NIMPHI=        51(MAXIMP=   1000000)
 -> NNB=           12(MAXNB=    1000000) 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> evaluate ($nstruc = 1) 
 EVALUATE: symbol $NSTRUC set to    1.00000     (real)
 CNSsolve> for $file in ( @@$coor_inlist )  loop main 
 ASSFIL: file file_2.list opened.
 FOR-clause="./data/sequence/protein2.pdb" 
 FOR LOOP: symbol FILE set to "./data/sequence/protein2.pdb" (string)
 FOR-clause= )  loop main 
 CNSsolve> 
 CNSsolve> set seed=$Saprotocol.iniseed end 
 CNSsolve> 
 CNSsolve> coor init end 
 COOR: selected main coordinates initialized
 CNSsolve> coordinates 
 COOR>   if ( &convert = true ) then 
 NEXTCD: condition evaluated as false
 COOR>     convert=true 
 COOR>   end if 
 COOR>   @@$file 
 ASSFIL: file protein2.pdb opened.
 COOR>ATOM      1  N   MET     2     -25.126 -15.124  33.576  1.00 35.36 
 COOR>ATOM      2  CA  MET     2     -24.995 -13.787  34.278  1.00 34.28 
 %READC-ERR: atom      6    TRP  OXT  not found in molecular structure
 %READC-WRN: still     11 missing coordinates (in selected subset)
 CNSsolve> 
 CNSsolve> show sum(1) ( not(hydrogen) and not(known) ) 
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 CNSsolve> if ( $select = 0 ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   display  %INFO: There are no coordinates missing for non-hydrogen atoms 
 %INFO: There are no coordinates missing for non-hydrogen atoms
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve> if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set message=normal echo=on end 
 CNSsolve> elseif ( $log_level = normal) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   set message=normal echo=off end 
 ASSFIL: file build-missing.cns opened.
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SHOW: sum over selected elements =      11.000000
 EVALUATE: symbol $TOBUILD set to    11.0000     (real)
 NEXTCD: condition evaluated as true
 SELRPN:     54 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SHOW: sum over selected elements =      11.000000
 EVALUATE: symbol $MOVING set to    11.0000     (real)
 NEXTCD: condition evaluated as true
 SELRPN:      4 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    1.00000     (real)
 SELRPN:      8 atoms have been selected out of     65
 SHOW: average of selected elements =     -25.474000
 EVALUATE: symbol $AVE_X set to   -25.4740     (real)
 SELRPN:      8 atoms have been selected out of     65
 SHOW: average of selected elements =     -13.284500
 EVALUATE: symbol $AVE_Y set to   -13.2845     (real)
 SELRPN:      8 atoms have been selected out of     65
 SHOW: average of selected elements =      34.678500
 EVALUATE: symbol $AVE_Z set to    34.6785     (real)
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    10.0000     (real)
 SELRPN:     14 atoms have been selected out of     65
 SHOW: average of selected elements =     -20.018500
 EVALUATE: symbol $AVE_X set to   -20.0185     (real)
 SELRPN:     14 atoms have been selected out of     65
 SHOW: average of selected elements =      -9.856500
 EVALUATE: symbol $AVE_Y set to   -9.85650     (real)
 SELRPN:     14 atoms have been selected out of     65
 SHOW: average of selected elements =      35.594071
 EVALUATE: symbol $AVE_Z set to    35.5941     (real)
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    26.0000     (real)
 SELRPN:     11 atoms have been selected out of     65
 SHOW: average of selected elements =     -22.495182
 EVALUATE: symbol $AVE_X set to   -22.4952     (real)
 SELRPN:     11 atoms have been selected out of     65
 SHOW: average of selected elements =     -14.368182
 EVALUATE: symbol $AVE_Y set to   -14.3682     (real)
 SELRPN:     11 atoms have been selected out of     65
 SHOW: average of selected elements =      38.960000
 EVALUATE: symbol $AVE_Z set to    38.9600     (real)
 SELRPN:      6 atoms have been selected out of     65
 SELRPN:      6 atoms have been selected out of     65
 SELRPN:      6 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    50.0000     (real)
 SELRPN:     14 atoms have been selected out of     65
 SHOW: average of selected elements =     -19.149071
 EVALUATE: symbol $AVE_X set to   -19.1491     (real)
 SELRPN:     14 atoms have been selected out of     65
 SHOW: average of selected elements =     -13.416143
 EVALUATE: symbol $AVE_Y set to   -13.4161     (real)
 SELRPN:     14 atoms have been selected out of     65
 SHOW: average of selected elements =      42.757857
 EVALUATE: symbol $AVE_Z set to    42.7579     (real)
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    2.00000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -25.126000
 EVALUATE: symbol $AVE_X set to   -25.1260     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -15.124000
 EVALUATE: symbol $AVE_Y set to   -15.1240     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      33.576000
 EVALUATE: symbol $AVE_Z set to    33.5760     (real)
 FOR ID LOOP: symbol ID set to    11.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -23.052000
 EVALUATE: symbol $AVE_X set to   -23.0520     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -12.315000
 EVALUATE: symbol $AVE_Y set to   -12.3150     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      34.343000
 EVALUATE: symbol $AVE_Z set to    34.3430     (real)
 FOR ID LOOP: symbol ID set to    18.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -17.643000
 EVALUATE: symbol $AVE_X set to   -17.6430     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -10.181000
 EVALUATE: symbol $AVE_Y set to   -10.1810     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      35.190000
 EVALUATE: symbol $AVE_Z set to    35.1900     (real)
 FOR ID LOOP: symbol ID set to    27.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -20.660000
 EVALUATE: symbol $AVE_X set to   -20.6600     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -12.584000
 EVALUATE: symbol $AVE_Y set to   -12.5840     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      36.927000
 EVALUATE: symbol $AVE_Z set to    36.9270     (real)
 FOR ID LOOP: symbol ID set to    33.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -24.698000
 EVALUATE: symbol $AVE_X set to   -24.6980     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -14.942000
 EVALUATE: symbol $AVE_Y set to   -14.9420     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.509000
 EVALUATE: symbol $AVE_Z set to    39.5090     (real)
 FOR ID LOOP: symbol ID set to    36.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -24.956000
 EVALUATE: symbol $AVE_X set to   -24.9560     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -17.183000
 EVALUATE: symbol $AVE_Y set to   -17.1830     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.961000
 EVALUATE: symbol $AVE_Z set to    39.9610     (real)
 FOR ID LOOP: symbol ID set to    37.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -24.956000
 EVALUATE: symbol $AVE_X set to   -24.9560     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -17.183000
 EVALUATE: symbol $AVE_Y set to   -17.1830     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.961000
 EVALUATE: symbol $AVE_Z set to    39.9610     (real)
 FOR ID LOOP: symbol ID set to    39.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -26.817000
 EVALUATE: symbol $AVE_X set to   -26.8170     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -15.869000
 EVALUATE: symbol $AVE_Y set to   -15.8690     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.615000
 EVALUATE: symbol $AVE_Z set to    39.6150     (real)
 FOR ID LOOP: symbol ID set to    40.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -26.817000
 EVALUATE: symbol $AVE_X set to   -26.8170     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -15.869000
 EVALUATE: symbol $AVE_Y set to   -15.8690     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.615000
 EVALUATE: symbol $AVE_Z set to    39.6150     (real)
 FOR ID LOOP: symbol ID set to    51.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -16.933000
 EVALUATE: symbol $AVE_X set to   -16.9330     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -12.681000
 EVALUATE: symbol $AVE_Y set to   -12.6810     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      41.247000
 EVALUATE: symbol $AVE_Z set to    41.2470     (real)
 FOR ID LOOP: symbol ID set to    58.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -20.369000
 EVALUATE: symbol $AVE_X set to   -20.3690     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -14.929000
 EVALUATE: symbol $AVE_Y set to   -14.9290     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      43.836000
 EVALUATE: symbol $AVE_Z set to    43.8360     (real)
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 SELRPN:     11 atoms have been selected out of     65
 EVALUATE: symbol $BATH set to    300.000     (real)
 EVALUATE: symbol $NSTEP set to    500.000     (real)
 EVALUATE: symbol $TIMESTEP set to   0.500000E-03 (real)
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 POWELL: number of degrees of freedom=    33
 NBONDS: generating intra-molecular exclusion list with mode=-2
 MAKINB: mode  -2 found     11 exclusions and      0 interactions(1-4)
 NBONDS: found      531 intra-atom interactions
 NBONDS: found      444 intra-atom interactions
 NBONDS: found      429 intra-atom interactions
 NBONDS: found      413 intra-atom interactions
 --------------- cycle=    10 ------ stepsize=   -0.0001 -----------------------
 | Etotal =896.663    grad(E)=199.660    E(BOND)=375.587    E(ANGL)=449.191    |
 | E(VDW )=71.885                                                              |
 -------------------------------------------------------------------------------
 NBONDS: found      406 intra-atom interactions
 --------------- cycle=    20 ------ stepsize=    0.0002 -----------------------
 | Etotal =52.288     grad(E)=29.563     E(BOND)=12.415     E(ANGL)=8.212      |
 | E(VDW )=31.661                                                              |
 -------------------------------------------------------------------------------
 --------------- cycle=    30 ------ stepsize=    0.0011 -----------------------
 | Etotal =36.736     grad(E)=20.174     E(BOND)=9.631      E(ANGL)=1.911      |
 | E(VDW )=25.194                                                              |
 -------------------------------------------------------------------------------
 --------------- cycle=    40 ------ stepsize=   -0.0008 -----------------------
 | Etotal =36.534     grad(E)=19.556     E(BOND)=8.873      E(ANGL)=1.909      |
 | E(VDW )=25.752                                                              |
 -------------------------------------------------------------------------------
 --------------- cycle=    50 ------ stepsize=    0.0027 -----------------------
 | Etotal =36.479     grad(E)=19.608     E(BOND)=8.774      E(ANGL)=2.045      |
 | E(VDW )=25.660                                                              |
 -------------------------------------------------------------------------------
 POWELL: STEP number limit. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=937.858         E(kin)=12.639        temperature=385.476    |
 | Etotal =925.219    grad(E)=122.002    E(BOND)=8.774      E(ANGL)=2.045      |
 | E(IMPR)=914.400                                                             |
 -------------------------------------------------------------------------------
 ----------------- final step=       50 at      0.02500 ps ---------------------
 | E(kin)+E(total)=412.464         E(kin)=265.134       temperature=8086.150   |
 | Etotal =147.330    grad(E)=62.664     E(BOND)=46.777     E(ANGL)=15.686     |
 | E(IMPR)=84.867                                                              |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -23.11222    -14.54453     38.36560
         velocity [A/ps]       :     -3.42803     -1.91305      3.18226
         ang. mom. [amu A/ps]  :  -2541.90218   4291.93622  -1536.54220
         kin. ener. [Kcal/mol] :      6.71407
 POWELL: number of degrees of freedom=    33
 NBONDS: found      401 intra-atom interactions
 --------------- cycle=    10 ------ stepsize=    0.0006 -----------------------
 | Etotal =36.516     grad(E)=19.392     E(BOND)=8.701      E(ANGL)=2.027      |
 | E(IMPR)=0.020      E(VDW )=25.769                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=    20 ------ stepsize=    0.0006 -----------------------
 | Etotal =36.472     grad(E)=19.563     E(BOND)=8.922      E(ANGL)=2.071      |
 | E(IMPR)=0.000      E(VDW )=25.479                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=    30 ------ stepsize=    0.0011 -----------------------
 | Etotal =36.472     grad(E)=19.562     E(BOND)=8.920      E(ANGL)=2.071      |
 | E(IMPR)=0.000      E(VDW )=25.481                                           |
 -------------------------------------------------------------------------------
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=45.949          E(kin)=9.476         temperature=289.016    |
 | Etotal =36.472     grad(E)=19.562     E(BOND)=8.921      E(ANGL)=2.071      |
 | E(IMPR)=0.000      E(VDW )=25.481                                           |
 -------------------------------------------------------------------------------
 ----------------- final step=       50 at      0.02500 ps ---------------------
 | E(kin)+E(total)=54.262          E(kin)=9.269         temperature=282.680    |
 | Etotal =44.994     grad(E)=28.606     E(BOND)=9.818      E(ANGL)=2.693      |
 | E(IMPR)=5.879      E(VDW )=26.603                                           |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -23.13260    -14.54944     38.40081
         velocity [A/ps]       :     -1.01781     -1.05867      0.14923
         ang. mom. [amu A/ps]  :    860.77825   -508.72872  -1299.27782
         kin. ener. [Kcal/mol] :      0.57287
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 POWELL: number of degrees of freedom=    33
 NBONDS: generating intra-molecular exclusion list with mode=-3
 MAKINB: mode  -3 found     30 exclusions and      0 interactions(1-4)
 NBONDS: found      381 intra-atom interactions
 --------------- cycle=    25 ------ stepsize=   -0.0000 -----------------------
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(IMPR)=0.000      E(VDW )=0.000                                            |
 -------------------------------------------------------------------------------
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=10.640          E(kin)=9.710         temperature=296.146    |
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(IMPR)=0.000      E(VDW )=0.000                                            |
 -------------------------------------------------------------------------------
 NBONDS: found      382 intra-atom interactions
 NBONDS: found      385 intra-atom interactions
 ----------------- final step=      500 at      0.25000 ps ---------------------
 | E(kin)+E(total)=17.136          E(kin)=10.437        temperature=318.325    |
 | Etotal =6.699      grad(E)=18.592     E(BOND)=1.002      E(ANGL)=3.045      |
 | E(IMPR)=2.652      E(VDW )=0.000                                            |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -22.97577    -14.56863     38.43672
         velocity [A/ps]       :     -0.53453     -1.25298     -0.31956
         ang. mom. [amu A/ps]  :  -1101.08524   -325.25886    568.90464
         kin. ener. [Kcal/mol] :      0.51472
 EFLAGS: the following energy flags are set
 EFLAGS: BOND ANGL DIHE IMPR VDW 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 POWELL: number of degrees of freedom=    33
 NBONDS: generating intra-molecular exclusion list with mode=-3
 MAKINB: mode  -3 found     30 exclusions and      0 interactions(1-4)
 NBONDS: found      387 intra-atom interactions
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=10.795          E(kin)=9.866         temperature=300.888    |
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=0.000      E(ELEC)=0.000      |
 -------------------------------------------------------------------------------
 NBONDS: found      384 intra-atom interactions
 NBONDS: found      384 intra-atom interactions
 NBONDS: found      381 intra-atom interactions
 NBONDS: found      387 intra-atom interactions
 NBONDS: found      385 intra-atom interactions
 NBONDS: found      382 intra-atom interactions
 NBONDS: found      381 intra-atom interactions
 NBONDS: found      382 intra-atom interactions
 NBONDS: found      387 intra-atom interactions
 NBONDS: found      387 intra-atom interactions
 NBONDS: found      384 intra-atom interactions
 ----------------- final step=      500 at      0.25000 ps ---------------------
 | E(kin)+E(total)=16.313          E(kin)=9.614         temperature=293.204    |
 | Etotal =6.699      grad(E)=17.478     E(BOND)=0.716      E(ANGL)=3.584      |
 | E(DIHE)=0.000      E(IMPR)=2.399      E(VDW )=0.000      E(ELEC)=0.000      |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -23.10299    -14.52542     38.36592
         velocity [A/ps]       :     -5.51256     -4.40807      4.66747
         ang. mom. [amu A/ps]  :    292.63991    148.79464   -139.70556
         kin. ener. [Kcal/mol] :      0.94880
 POWELL: number of degrees of freedom=    33
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 Number of violations greater    0.020:     0
 RMS deviation=   0.000
 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 Number of violations greater    5.000:     0
 RMS deviation=   0.567
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 Number of violations greater than    5.000:     0
 RMS deviation=   0.000
 --------------- cycle=     1 --------------------------------------------------
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=0.000      E(ELEC)=0.000      |
 | E(CDIH)=0.000      E(NOE )=0.000                                            |
 -------------------------------------------------------------------------------
 SELRPN:     65 atoms have been selected out of     65
 ASSFIL: file flex_segment_back.cns opened.
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 EVALUATE: symbol $NF set to    0.00000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 1
 ASSFIL: file flexauto-neighbors.cns opened.
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 1
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 EVALUATE: symbol $NF set to    0.00000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 2
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 2
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 NEXTCD: condition evaluated as true
NO FULLY FLEXIBLE SEGMENTS for molecule 1
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 NEXTCD: condition evaluated as true
NO FULLY FLEXIBLE SEGMENTS for molecule 2
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMFLE set to    0.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMRIG set to    0.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMRES set to    0.00000     (real)
FLEXIBILITY STATISTIC FOR MOLECULE 1 : Nres=0 Nrigid=0 Nflex=0
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMFLE set to    0.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      5 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       5.000000
 EVALUATE: symbol $NUMRIG set to    5.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      5 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       5.000000
 EVALUATE: symbol $NUMRES set to    5.00000     (real)
FLEXIBILITY STATISTIC FOR MOLECULE 2 : Nres=5 Nrigid=5 Nflex=0
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 NEXTCD: condition evaluated as false
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 EVALUATE: symbol $NFLETOT set to    10.0000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 NEXTCD: condition evaluated as false
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 Number of violations greater than    5.000:     0
 RMS deviation=   0.000
 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 Number of violations greater    0.020:     0
 RMS deviation=   0.000
 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 Number of violations greater    5.000:     0
 RMS deviation=   0.567
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 %POWELL-ERR: all atoms fixed. No action
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as true
 ASSFIL: file prot_break.cns opened.
 EVALUATE: symbol $PBREAK set to    0.00000     (real)
 SELRPN:      5 atoms have been selected out of     65
 FOR ID LOOP: symbol ID1 set to    8.00000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      MET  2    C    )      
 EVALUATE: symbol $SEGID1 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      MET  2    C    )  2   
 EVALUATE: symbol $RESID1 set to "2" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      MET  2    C    )  MET 
 EVALUATE: symbol $RESN1 set to "MET" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    N    )    10.000    
 EVALUATE: symbol $ID2 set to    10.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    N    )      
 EVALUATE: symbol $SEGID2 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    N    )  3   
 EVALUATE: symbol $RESID2 set to "3" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    N    )  TRP 
 EVALUATE: symbol $RESN2 set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 GEOM=      1.332032
 NEXTCD: condition evaluated as false
 FOR ID LOOP: symbol ID1 set to    24.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    C    )      
 EVALUATE: symbol $SEGID1 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    C    )  3   
 EVALUATE: symbol $RESID1 set to "3" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    C    )  TRP 
 EVALUATE: symbol $RESN1 set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    N    )    26.000    
 EVALUATE: symbol $ID2 set to    26.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    N    )      
 EVALUATE: symbol $SEGID2 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    N    )  4   
 EVALUATE: symbol $RESID2 set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    N    )  ARG 
 EVALUATE: symbol $RESN2 set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 GEOM=      1.345877
 NEXTCD: condition evaluated as false
 FOR ID LOOP: symbol ID1 set to    41.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    C    )      
 EVALUATE: symbol $SEGID1 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    C    )  4   
 EVALUATE: symbol $RESID1 set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    C    )  ARG 
 EVALUATE: symbol $RESN1 set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    N    )    43.000    
 EVALUATE: symbol $ID2 set to    43.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    N    )      
 EVALUATE: symbol $SEGID2 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    N    )  5   
 EVALUATE: symbol $RESID2 set to "5" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    N    )  PRO 
 EVALUATE: symbol $RESN2 set to "PRO" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 GEOM=      1.342297
 NEXTCD: condition evaluated as false
 FOR ID LOOP: symbol ID1 set to    48.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    C    )      
 EVALUATE: symbol $SEGID1 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    C    )  5   
 EVALUATE: symbol $RESID1 set to "5" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    C    )  PRO 
 EVALUATE: symbol $RESN1 set to "PRO" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    N    )    50.000    
 EVALUATE: symbol $ID2 set to    50.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    N    )      
 EVALUATE: symbol $SEGID2 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    N    )  6   
 EVALUATE: symbol $RESID2 set to "6" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    N    )  TRP 
 EVALUATE: symbol $RESN2 set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 GEOM=      1.329959
 NEXTCD: condition evaluated as false
 FOR ID LOOP: symbol ID1 set to    64.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    C    )      
 EVALUATE: symbol $SEGID1 set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    C    )  6   
 EVALUATE: symbol $RESID1 set to "6" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    C    )  TRP 
 EVALUATE: symbol $RESN1 set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 NEXTCD: condition evaluated as false
 ASSFIL: file dna_break.cns opened.
 EVALUATE: symbol $DBREAK set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $DISU set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 ASSFIL: file covalheme.cns opened.
 EVALUATE: symbol $NCAC set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $NCAB set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 NEXTCD: condition evaluated as false
 ASSFIL: file coval-ace-cys.cns opened.
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $IRONCLUS set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $IRONCLUS set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $COUNTER set to    1.00000     (real)
 NEXTCD: condition evaluated as false
 SELRPN:      1 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    44.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    CA   )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    CA   )  5   
 EVALUATE: symbol $RESID set to "5" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      PRO  5    CA   )  PRO 
 EVALUATE: symbol $RESN set to "PRO" (string)
 SELRPN:      1 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    C    )    41.000    
 EVALUATE: symbol $ID_PREV set to    41.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    C    )      
 EVALUATE: symbol $SEGID_PREV set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    C    )  4   
 EVALUATE: symbol $RESID_PREV set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    C    )  ARG 
 EVALUATE: symbol $RESN_PREV set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 GEOM=   -171.252795
 EVALUATE: symbol $DIHEDRAL set to    188.747     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $DIHEDRAL set to   -171.253     (real)
 EVALUATE: symbol $ABSDIHEDRAL set to    171.253     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 SCRATC-warning: Pairs of Interacting Groups erased.
 SCRATC-warning: STORe selections erased.
 Status of internal molecular topology database:
 -> NATOM=         65(MAXA=     1000000)  NBOND=         69(MAXB=     1000000)
 -> NTHETA=        98(MAXT=     2000000)  NGRP=           5(MAXGRP=   1000000)
 -> NPHI=          95(MAXP=     2000000)  NIMPHI=        51(MAXIMP=   1000000)
 -> NNB=           12(MAXNB=    1000000) 
 ASSFIL: file build-missing.cns opened.
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SHOW: sum over selected elements =      11.000000
 EVALUATE: symbol $TOBUILD set to    11.0000     (real)
 NEXTCD: condition evaluated as true
 SELRPN:     54 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SHOW: sum over selected elements =      11.000000
 EVALUATE: symbol $MOVING set to    11.0000     (real)
 NEXTCD: condition evaluated as true
 SELRPN:      4 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    1.00000     (real)
 SELRPN:      9 atoms have been selected out of     65
 SHOW: average of selected elements =     -25.493890
 EVALUATE: symbol $AVE_X set to   -25.4939     (real)
 SELRPN:      9 atoms have been selected out of     65
 SHOW: average of selected elements =     -13.495364
 EVALUATE: symbol $AVE_Y set to   -13.4954     (real)
 SELRPN:      9 atoms have been selected out of     65
 SHOW: average of selected elements =      34.464425
 EVALUATE: symbol $AVE_Z set to    34.4644     (real)
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      1 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    10.0000     (real)
 SELRPN:     16 atoms have been selected out of     65
 SHOW: average of selected elements =     -20.032820
 EVALUATE: symbol $AVE_X set to   -20.0328     (real)
 SELRPN:     16 atoms have been selected out of     65
 SHOW: average of selected elements =     -10.003404
 EVALUATE: symbol $AVE_Y set to   -10.0034     (real)
 SELRPN:     16 atoms have been selected out of     65
 SHOW: average of selected elements =      35.462409
 EVALUATE: symbol $AVE_Z set to    35.4624     (real)
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    26.0000     (real)
 SELRPN:     17 atoms have been selected out of     65
 SHOW: average of selected elements =     -23.342919
 EVALUATE: symbol $AVE_X set to   -23.3429     (real)
 SELRPN:     17 atoms have been selected out of     65
 SHOW: average of selected elements =     -14.838417
 EVALUATE: symbol $AVE_Y set to   -14.8384     (real)
 SELRPN:     17 atoms have been selected out of     65
 SHOW: average of selected elements =      39.034492
 EVALUATE: symbol $AVE_Z set to    39.0345     (real)
 SELRPN:      6 atoms have been selected out of     65
 SELRPN:      6 atoms have been selected out of     65
 SELRPN:      6 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    50.0000     (real)
 SELRPN:     16 atoms have been selected out of     65
 SHOW: average of selected elements =     -19.178927
 EVALUATE: symbol $AVE_X set to   -19.1789     (real)
 SELRPN:     16 atoms have been selected out of     65
 SHOW: average of selected elements =     -13.512611
 EVALUATE: symbol $AVE_Y set to   -13.5126     (real)
 SELRPN:     16 atoms have been selected out of     65
 SHOW: average of selected elements =      42.739024
 EVALUATE: symbol $AVE_Z set to    42.7390     (real)
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      2 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_X set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Y set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $AVE_Z set to    0.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    2.00000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -25.126000
 EVALUATE: symbol $AVE_X set to   -25.1260     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -15.124000
 EVALUATE: symbol $AVE_Y set to   -15.1240     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      33.576000
 EVALUATE: symbol $AVE_Z set to    33.5760     (real)
 FOR ID LOOP: symbol ID set to    11.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -23.052000
 EVALUATE: symbol $AVE_X set to   -23.0520     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -12.315000
 EVALUATE: symbol $AVE_Y set to   -12.3150     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      34.343000
 EVALUATE: symbol $AVE_Z set to    34.3430     (real)
 FOR ID LOOP: symbol ID set to    18.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -17.643000
 EVALUATE: symbol $AVE_X set to   -17.6430     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -10.181000
 EVALUATE: symbol $AVE_Y set to   -10.1810     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      35.190000
 EVALUATE: symbol $AVE_Z set to    35.1900     (real)
 FOR ID LOOP: symbol ID set to    27.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -20.660000
 EVALUATE: symbol $AVE_X set to   -20.6600     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -12.584000
 EVALUATE: symbol $AVE_Y set to   -12.5840     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      36.927000
 EVALUATE: symbol $AVE_Z set to    36.9270     (real)
 FOR ID LOOP: symbol ID set to    33.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -24.698000
 EVALUATE: symbol $AVE_X set to   -24.6980     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -14.942000
 EVALUATE: symbol $AVE_Y set to   -14.9420     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.509000
 EVALUATE: symbol $AVE_Z set to    39.5090     (real)
 FOR ID LOOP: symbol ID set to    36.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -24.956000
 EVALUATE: symbol $AVE_X set to   -24.9560     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -17.183000
 EVALUATE: symbol $AVE_Y set to   -17.1830     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.961000
 EVALUATE: symbol $AVE_Z set to    39.9610     (real)
 FOR ID LOOP: symbol ID set to    37.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -24.956000
 EVALUATE: symbol $AVE_X set to   -24.9560     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -17.183000
 EVALUATE: symbol $AVE_Y set to   -17.1830     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.961000
 EVALUATE: symbol $AVE_Z set to    39.9610     (real)
 FOR ID LOOP: symbol ID set to    39.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -26.817000
 EVALUATE: symbol $AVE_X set to   -26.8170     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -15.869000
 EVALUATE: symbol $AVE_Y set to   -15.8690     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.615000
 EVALUATE: symbol $AVE_Z set to    39.6150     (real)
 FOR ID LOOP: symbol ID set to    40.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -26.817000
 EVALUATE: symbol $AVE_X set to   -26.8170     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -15.869000
 EVALUATE: symbol $AVE_Y set to   -15.8690     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      39.615000
 EVALUATE: symbol $AVE_Z set to    39.6150     (real)
 FOR ID LOOP: symbol ID set to    51.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -16.933000
 EVALUATE: symbol $AVE_X set to   -16.9330     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -12.681000
 EVALUATE: symbol $AVE_Y set to   -12.6810     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      41.247000
 EVALUATE: symbol $AVE_Z set to    41.2470     (real)
 FOR ID LOOP: symbol ID set to    58.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: sum over selected elements =       1.000000
 NEXTCD: condition evaluated as true
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -20.369000
 EVALUATE: symbol $AVE_X set to   -20.3690     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =     -14.929000
 EVALUATE: symbol $AVE_Y set to   -14.9290     (real)
 SELRPN:      1 atoms have been selected out of     65
 SHOW: average of selected elements =      43.836000
 EVALUATE: symbol $AVE_Z set to    43.8360     (real)
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 SELRPN:     11 atoms have been selected out of     65
 EVALUATE: symbol $BATH set to    300.000     (real)
 EVALUATE: symbol $NSTEP set to    500.000     (real)
 EVALUATE: symbol $TIMESTEP set to   0.500000E-03 (real)
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 POWELL: number of degrees of freedom=    33
 NBONDS: generating intra-molecular exclusion list with mode=-2
 MAKINB: mode  -2 found     11 exclusions and      0 interactions(1-4)
 NBONDS: found      533 intra-atom interactions
 NBONDS: found      445 intra-atom interactions
 NBONDS: found      425 intra-atom interactions
 NBONDS: found      414 intra-atom interactions
 --------------- cycle=    10 ------ stepsize=    0.0001 -----------------------
 | Etotal =366.846    grad(E)=102.920    E(BOND)=42.975     E(ANGL)=190.794    |
 | E(VDW )=133.077                                                             |
 -------------------------------------------------------------------------------
 --------------- cycle=    20 ------ stepsize=   -0.0000 -----------------------
 | Etotal =40.942     grad(E)=23.937     E(BOND)=12.309     E(ANGL)=2.564      |
 | E(VDW )=26.068                                                              |
 -------------------------------------------------------------------------------
 --------------- cycle=    30 ------ stepsize=    0.0006 -----------------------
 | Etotal =36.786     grad(E)=19.970     E(BOND)=9.157      E(ANGL)=1.986      |
 | E(VDW )=25.642                                                              |
 -------------------------------------------------------------------------------
 --------------- cycle=    40 ------ stepsize=    0.0003 -----------------------
 | Etotal =36.500     grad(E)=19.675     E(BOND)=9.049      E(ANGL)=1.991      |
 | E(VDW )=25.460                                                              |
 -------------------------------------------------------------------------------
 --------------- cycle=    50 ------ stepsize=    0.0005 -----------------------
 | Etotal =36.470     grad(E)=19.590     E(BOND)=8.946      E(ANGL)=1.987      |
 | E(VDW )=25.538                                                              |
 -------------------------------------------------------------------------------
 POWELL: STEP number limit. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=670.047         E(kin)=11.254        temperature=343.221    |
 | Etotal =658.793    grad(E)=64.888     E(BOND)=8.946      E(ANGL)=1.987      |
 | E(IMPR)=647.860                                                             |
 -------------------------------------------------------------------------------
 ----------------- final step=       50 at      0.02500 ps ---------------------
 | E(kin)+E(total)=467.402         E(kin)=211.995       temperature=6465.499   |
 | Etotal =255.407    grad(E)=60.049     E(BOND)=14.162     E(ANGL)=2.955      |
 | E(IMPR)=238.291                                                             |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -23.15127    -14.56266     38.43173
         velocity [A/ps]       :     -0.91454     -0.31263      0.03434
         ang. mom. [amu A/ps]  :  -2679.11657     69.32906   -889.87182
         kin. ener. [Kcal/mol] :      0.24589
 POWELL: number of degrees of freedom=    33
 NBONDS: found      397 intra-atom interactions
 NBONDS: found      400 intra-atom interactions
 --------------- cycle=    10 ------ stepsize=    0.0007 -----------------------
 | Etotal =36.588     grad(E)=19.619     E(BOND)=8.796      E(ANGL)=2.059      |
 | E(IMPR)=0.106      E(VDW )=25.628                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=    20 ------ stepsize=    0.0007 -----------------------
 | Etotal =36.473     grad(E)=19.564     E(BOND)=8.928      E(ANGL)=2.070      |
 | E(IMPR)=0.000      E(VDW )=25.475                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=    30 ------ stepsize=    0.0005 -----------------------
 | Etotal =36.472     grad(E)=19.562     E(BOND)=8.921      E(ANGL)=2.071      |
 | E(IMPR)=0.000      E(VDW )=25.481                                           |
 -------------------------------------------------------------------------------
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=46.260          E(kin)=9.788         temperature=298.504    |
 | Etotal =36.472     grad(E)=19.562     E(BOND)=8.921      E(ANGL)=2.071      |
 | E(IMPR)=0.000      E(VDW )=25.481                                           |
 -------------------------------------------------------------------------------
 ----------------- final step=       50 at      0.02500 ps ---------------------
 | E(kin)+E(total)=52.137          E(kin)=10.236        temperature=312.174    |
 | Etotal =41.901     grad(E)=24.748     E(BOND)=8.548      E(ANGL)=3.621      |
 | E(IMPR)=3.317      E(VDW )=26.415                                           |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -23.13216    -14.55899     38.44552
         velocity [A/ps]       :     -0.00022     -0.84893      0.10796
         ang. mom. [amu A/ps]  :  -1405.96878    869.82128    439.52264
         kin. ener. [Kcal/mol] :      0.19253
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 POWELL: number of degrees of freedom=    33
 NBONDS: generating intra-molecular exclusion list with mode=-3
 MAKINB: mode  -3 found     30 exclusions and      0 interactions(1-4)
 NBONDS: found      381 intra-atom interactions
 --------------- cycle=    25 ------ stepsize=    0.0000 -----------------------
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(IMPR)=0.000      E(VDW )=0.000                                            |
 -------------------------------------------------------------------------------
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=11.747          E(kin)=10.818        temperature=329.927    |
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(IMPR)=0.000      E(VDW )=0.000                                            |
 -------------------------------------------------------------------------------
 NBONDS: found      385 intra-atom interactions
 NBONDS: found      387 intra-atom interactions
 NBONDS: found      385 intra-atom interactions
 ----------------- final step=      500 at      0.25000 ps ---------------------
 | E(kin)+E(total)=15.145          E(kin)=10.271        temperature=313.259    |
 | Etotal =4.874      grad(E)=15.255     E(BOND)=0.650      E(ANGL)=2.363      |
 | E(IMPR)=1.861      E(VDW )=0.000                                            |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -23.00324    -14.54256     38.36967
         velocity [A/ps]       :     -1.08987      0.70236     -0.52997
         ang. mom. [amu A/ps]  :   -101.39255   1158.35224   -188.92000
         kin. ener. [Kcal/mol] :      0.51582
 EFLAGS: the following energy flags are set
 EFLAGS: BOND ANGL DIHE IMPR VDW 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 POWELL: number of degrees of freedom=    33
 NBONDS: generating intra-molecular exclusion list with mode=-3
 MAKINB: mode  -3 found     30 exclusions and      0 interactions(1-4)
 NBONDS: found      383 intra-atom interactions
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 SELRPN:     11 atoms have been selected out of     65
 DCART: temperature coupling (TCOUpling) enabled
 -------------------------- Cartesian dynamics start ---------------------------
 | E(kin)+E(total)=9.234           E(kin)=8.305         temperature=253.294    |
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=0.000      E(ELEC)=0.000      |
 -------------------------------------------------------------------------------
 NBONDS: found      386 intra-atom interactions
 NBONDS: found      386 intra-atom interactions
 NBONDS: found      383 intra-atom interactions
 NBONDS: found      384 intra-atom interactions
 NBONDS: found      382 intra-atom interactions
 NBONDS: found      387 intra-atom interactions
 ----------------- final step=      500 at      0.25000 ps ---------------------
 | E(kin)+E(total)=19.466          E(kin)=8.730         temperature=266.253    |
 | Etotal =10.736     grad(E)=21.952     E(BOND)=1.067      E(ANGL)=6.910      |
 | E(DIHE)=0.000      E(IMPR)=2.759      E(VDW )=0.000      E(ELEC)=0.000      |
 -------------------------------------------------------------------------------
 CENMAS: Information about center of free masses
         position [A]          :    -23.01039    -14.60306     38.48118
         velocity [A/ps]       :     -0.38233      0.06203      9.14361
         ang. mom. [amu A/ps]  :     59.87333    221.88334     76.52320
         kin. ener. [Kcal/mol] :      1.10980
 POWELL: number of degrees of freedom=    33
 POWELL: Gradient converged. Normal termination
 POWELL: Current coordinates set to last minimum
 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 Number of violations greater    0.020:     0
 RMS deviation=   0.000
 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 Number of violations greater    5.000:     0
 RMS deviation=   0.567
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 Number of violations greater than    5.000:     0
 RMS deviation=   0.000
 --------------- cycle=     2 --------------------------------------------------
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=0.000      E(ELEC)=0.000      |
 | E(CDIH)=0.000      E(NOE )=0.000                                            |
 -------------------------------------------------------------------------------
 SELRPN:     65 atoms have been selected out of     65
 ASSFIL: file flex_segment_back.cns opened.
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 EVALUATE: symbol $NF set to    0.00000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 1
 ASSFIL: file flexauto-neighbors.cns opened.
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 1
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 EVALUATE: symbol $NF set to    0.00000     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as true
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 2
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 2
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as false
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 NEXTCD: condition evaluated as true
NO FULLY FLEXIBLE SEGMENTS for molecule 1
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 NEXTCD: condition evaluated as true
NO FULLY FLEXIBLE SEGMENTS for molecule 2
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMFLE set to    0.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMRIG set to    0.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMRES set to    0.00000     (real)
FLEXIBILITY STATISTIC FOR MOLECULE 1 : Nres=0 Nrigid=0 Nflex=0
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       0.000000
 EVALUATE: symbol $NUMFLE set to    0.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      5 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       5.000000
 EVALUATE: symbol $NUMRIG set to    5.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      5 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 SHOW: sum over selected elements =       5.000000
 EVALUATE: symbol $NUMRES set to    5.00000     (real)
FLEXIBILITY STATISTIC FOR MOLECULE 2 : Nres=5 Nrigid=5 Nflex=0
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 NEXTCD: condition evaluated as false
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 EVALUATE: symbol $NFLETOT set to    10.0000     (real)
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 NEXTCD: condition evaluated as false
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 Number of violations greater than    5.000:     0
 RMS deviation=   0.000
 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 Number of violations greater    0.020:     0
 RMS deviation=   0.000
 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 Number of violations greater    5.000:     0
 RMS deviation=   0.567
 SELRPN:     65 atoms have been selected out of     65
 SELRPN:      0 atoms have been selected out of     65
 SELRPN:     65 atoms have been selected out of     65
 %POWELL-ERR: all atoms fixed. No action
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 NEXTCD: condition evaluated as false
 ASSFIL: file auto-his.cns opened.
 --------------- cycle=     3 --------------------------------------------------
 | Etotal =0.929      grad(E)=3.481      E(BOND)=0.000      E(ANGL)=0.929      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=0.000      E(ELEC)=0.000      |
 -------------------------------------------------------------------------------
 EVALUATE: symbol $BONDED set to   0.929268     (real)
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 SELRPN:      0 atoms have been selected out of     65
 SHOW: zero atoms selected
 NEXTCD: condition evaluated as true
 SELRPN:      0 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 SELRPN:     65 atoms have been selected out of     65
 NEXTCD: condition evaluated as false
 NEXTCD: condition evaluated as false
 SELRPN:     11 atoms have been selected out of     65
 SHOW: sum over selected elements =      11.000000
 NEXTCD: condition evaluated as true
 SELRPN:     11 atoms have been selected out of     65
 FOR ID LOOP: symbol ID set to    2.00000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      MET  2    HN   )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      MET  2    HN   )  MET 
 EVALUATE: symbol $RESN set to "MET" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      MET  2    HN   )  2   
 EVALUATE: symbol $RESID set to "2" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      MET  2    HN   )  HN  
 EVALUATE: symbol $NAME set to "HN" (string)
 FOR ID LOOP: symbol ID set to    11.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HN   )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HN   )  TRP 
 EVALUATE: symbol $RESN set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HN   )  3   
 EVALUATE: symbol $RESID set to "3" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HN   )  HN  
 EVALUATE: symbol $NAME set to "HN" (string)
 FOR ID LOOP: symbol ID set to    18.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HE1  )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HE1  )  TRP 
 EVALUATE: symbol $RESN set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HE1  )  3   
 EVALUATE: symbol $RESID set to "3" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  3    HE1  )  HE1 
 EVALUATE: symbol $NAME set to "HE1" (string)
 FOR ID LOOP: symbol ID set to    27.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HN   )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HN   )  ARG 
 EVALUATE: symbol $RESN set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HN   )  4   
 EVALUATE: symbol $RESID set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HN   )  HN  
 EVALUATE: symbol $NAME set to "HN" (string)
 FOR ID LOOP: symbol ID set to    33.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HE   )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HE   )  ARG 
 EVALUATE: symbol $RESN set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HE   )  4   
 EVALUATE: symbol $RESID set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HE   )  HE  
 EVALUATE: symbol $NAME set to "HE" (string)
 FOR ID LOOP: symbol ID set to    36.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH11 )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH11 )  ARG 
 EVALUATE: symbol $RESN set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH11 )  4   
 EVALUATE: symbol $RESID set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH11 )  HH11
 EVALUATE: symbol $NAME set to "HH11" (string)
 FOR ID LOOP: symbol ID set to    37.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH12 )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH12 )  ARG 
 EVALUATE: symbol $RESN set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH12 )  4   
 EVALUATE: symbol $RESID set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH12 )  HH12
 EVALUATE: symbol $NAME set to "HH12" (string)
 FOR ID LOOP: symbol ID set to    39.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH21 )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH21 )  ARG 
 EVALUATE: symbol $RESN set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH21 )  4   
 EVALUATE: symbol $RESID set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH21 )  HH21
 EVALUATE: symbol $NAME set to "HH21" (string)
 FOR ID LOOP: symbol ID set to    40.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH22 )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH22 )  ARG 
 EVALUATE: symbol $RESN set to "ARG" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH22 )  4   
 EVALUATE: symbol $RESID set to "4" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      ARG  4    HH22 )  HH22
 EVALUATE: symbol $NAME set to "HH22" (string)
 FOR ID LOOP: symbol ID set to    51.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HN   )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HN   )  TRP 
 EVALUATE: symbol $RESN set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HN   )  6   
 EVALUATE: symbol $RESID set to "6" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HN   )  HN  
 EVALUATE: symbol $NAME set to "HN" (string)
 FOR ID LOOP: symbol ID set to    58.0000     (real)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HE1  )      
 EVALUATE: symbol $SEGID set to "" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HE1  )  TRP 
 EVALUATE: symbol $RESN set to "TRP" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HE1  )  6   
 EVALUATE: symbol $RESID set to "6" (string)
 SELRPN:      1 atoms have been selected out of     65
 (      TRP  6    HE1  )  HE1 
 EVALUATE: symbol $NAME set to "HE1" (string)
 SELRPN:     65 atoms have been selected out of     65
 NEXTCD: condition evaluated as true
 ASSFIL: file protein2.pdb opened.
 EVALUATE: symbol $FILENAME_1 set to "BEGIN:protein2_1.pdb" (string)
 ASSFIL: file protein2_1.pdb opened.
 EVALUATE: symbol $NSTRUC set to    2.00000     (real)
 SELRPN:     65 atoms have been selected out of     65
 ASSFIL: file file_2.list opened.
 EVALUATE: symbol $DISFILE set to "BEGIN:file_2.list" (string)
 ASSFIL: file file_2.list opened.
 EVALUATE: symbol $NUM set to    1.00000     (real)
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $OUTSTRING set to ""BEGIN:protein2_1.pdb"" (string)
 EVALUATE: symbol $NUM set to    2.00000     (real)
 NEXTCD: condition evaluated as false
 SELRPN:     65 atoms have been selected out of     65
 ASSFIL: file protein2.psf opened.
 ASSFIL: file protein2.psf opened.
 HEAP: maximum use      =     9951512 current use      =       96000 bytes
 HEAP: maximum overhead =        2096 current overhead =         752 bytes
 VCLOSE: Display file reset to OUTPUT.
          ============================================================
           Maximum dynamic memory allocation:     9951512 bytes
           Maximum dynamic memory overhead:          2096 bytes
           Program started at: 23:48:28 on 01-Nov-2022
           Program stopped at: 23:48:28 on 01-Nov-2022
           CPU time used:       0.3303 seconds
          ============================================================
